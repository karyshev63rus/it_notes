Git - инструменты тестировщика (Арсений Батыров)
------------------------------------------------

Создаем файл конфигурации .gitconfig, куда прописываем:
[user]
    email=karyshev63rus@gmail.com
    name=karyshev63rus
Просмотр конфигурационного файла: git config --list --global

Далее создаем репозиторий на github и клонируем его на машину: git clone <ссылка на удаленный репо>
Создаем файл и пишем в него одну строку
Проверка статуса с целью выявить неотслеженные файлы: git status (красный)

Добавление неотслеженного файла куда-то там (в stage?): git add <filename>
еще раз проверка статуса: теперь файл зеленый

Дописываем еще одну строку и проверяем статус: файл теперь и зеленый (new file), и красный (modified) - здесь мы можем либо откатить изменения назад,т.е. отказаться от модификации (git checkout -- <filename> или git restore <filename>), либо добавить изменения командой git add <filename>

Фиксируем новое состояние проекта командой git commit -m init "my first commit"

Смотрим на изменения в удаленном репо. Они есть. Изменяем файл на удаленном репо и возвращаемся к локальному репо, проверяем его состояние: git status. Никаких изменений не видно, так как они были сделаны не через локальный репо

Для получения информации об изменениях на удаленном репо набираем git fetch
и далее git status - видим, что локальный отстает на один коммит

Версии веток:
master - это локальная рабочая ветка (Клиент, ветка расположена на нашей машине)
origin master - это версия ветки на удаленном репозитории (Сервер, - на сервере)
origin/master - это тоже локальная, но нерабочая версия ветки (в ней хранится та информация, которую мы знали об удаленном репозитории на момент последнего выполнения команды git fetch). Она нужна для того, чтобы понять, в каком состоянии находится наша локальная ветка относительно origin ветки. Когда делается git fetch, именно в эту ветку поступает информация о состоянии origin master. Наша ветка master при этом никак не меняется.
Важно помнить, что master - это только одно из имен ветки. Если наша локальная ветка называется, к примеру, "test", то ветка на сервере будет "origin test",а локальная ветка для git fetch будет называться "origin/test".

Стратегия fast-forward - по сути это одна из стратегий слияния локальной и удаленной веток проекта. Предположим, что в мастер-ветке (на удаленном репо) у нас был коммит А. Мы внесли какие-то изменения и сделали коммит С в нашем локальном мастере, но в это время в origin уже кто-то добавил какие-то другие изменения в виде коммита В., т.е. сложилась конфигурация А-С и А-В. Если компоненты коммитов В и С никак не мешают друг другу и могут быть представлены в конфигурации А-В-С, то git выбирает стратегию Fast forward, просто меняя предка для С с А на В.

Соглашаемся на предложенную системой стратегию и выполняем команду git pull, после чего выводится информация о том, какие файлы и в каком объеме были изменены. В частности, пишется, например, такое: "Updating 757d1ef..e534f31" - каждый раз,когда мы что-то коммитим, формируется хэш-коммит (хэш - это набор символов,который уникален для каждого коммита в данном репозитории).
Существует команда, которая показывает историю всех изменений нашего репозитория- это git log

Посмотреть историю коммитов, сделанных определенным пользователем: 
git log --author <username>
Команда, позволяющая посмотреть изменения, сделанные в конкретном коммите: 
git show <хэш коммита>
название файла до коммита: --- /dev/null (если только что создали, то оно будет dev/null)
Название файла после коммита: +++ b/some.file`
Между значками @@ будут указаны строки, которые затронули изменения, например, 
@@ -0,0 +1,2 @@
Ниже идет содержимое файла. Знаком "+" показывается строка, которая была добавлена, а со знаком "-" - которая была удалена
Если выполнить git show без указания хэша, то будет выведена информация по последнему коммиту

Посмотреть авторов файла можно при помощи команды git blame <filename>
Автора конкретной строки выявляем так: git blame <filename> | grep <string> 
Поиск по автору: git blame <filename> | grep <username>
Вывести все строки конкретного коммита: git blame <filename> | grep <hash>

Команда git diff выводит изменения файла с момента последнего коммита(?), этот вывод похож на результат команды git show

Варианты команды git commit:
git commit -a -m "change lines in some.file" - ключ -a означает, что коммититься будут все файлы в локальном репо
разобрать коммит можно так: указатель HEAD говорит о том, какая ветка текущая и какой коммит в ней последний 
команда reset может двигать HEAD на несколько позиций (здесь будем рассматривать случай сдвига на одну позицию; при этом коммит, на который указывал HEAD, будет разобран)
1-й вариант: git reset HEAD~1 - сдвиг коммита на одну позицию (вывод покажет, какие файлы оказались разобранными; изменения будут видимы и не удалены, т.е. файлы будут приведены к их состоянию перед отмененным шкоммитом)
2-й вариант: git reset HEAD~1 --hard - все изменения пропали (так понимаю, откат до состояния предыдушего коммита)
Добавим файл в уже собранный коммит: git commit --amend (тут же должен открыться редактор по умолчанию и показать список уже закоммиченных файлов и список файлов, еще не добавленных и, соответственно, незакомиченных). Добавляем незакомиченные файлы командой git add <названия файлов>. Если снова вызовем git commit --amend и увидим, что незакомиченные файлы добавлены в коммит. Для подтверждения этого положения надо сохранить открывшийся текстовый файл редактора.

Если во время нашей работы в локальном репо были внесены изменения в глобальный репо - например, созданы новые файлы - то непосредственно выполнить команду заливки локальных изменений на удаленный репо: git push - сделать будет нельзя
Сначала надо скачать все изменения, которые были сделаны другими участниками проекта (есть вариант применения ключа force, но это затрет коммиты, сделанные другими участниками), поэтому делаем git pull - при этом открывается текстовый редактор и предлагает объяснить назначение операции, можно просто сохранить файл и закрыть его, после чего происходит так называемый merge commit 
Merge commit - это коммит, у которого два родительских коммита. Например, в нашей ветке был только коммит А, затем мы с ней локально и сделали новый коммит С, за это время кто-то уже сделал коммит В и успел его запушить. Теперь нам надо выложить коммит, мы делаем push, но у нас не получается сделать этого, потому что наши коммиты не синхронизированы. Поэтому нам сначала нужно стянуть изменения из origin, для чего мы делаем pull. В результате работы схема должна стать такой: А-В-С, т.е. коммиты должны идти последовательно. Но для этого нам надо сделать так, чтобы у нового коммита - назовем его М - стало два предка. Этот коммит М (коммит слияния) указывает на то, что произошло слияние двух историй в одну. 
Получив коммит слияния, мы можем делать git push.

В рассмотренной ситуации в репо меняются только разные файлы, так что при слиянии проблем нет. Однако бывает и такое, что изменяется один и тот же файл, более того, даже одна и та же строка. Такую ситуацию git сам решить не может, так как не может выбрать порядок строк, а он может быть важен, например, для кода. В  этой ситуации возникает конфликт. Смоделируем такую ситуацию.
В локальном репозитории в файле some.file изменяем первую строку - напишем 'Change first line from terminal'
В удаленном репозитоварии в том же файле изменяем первую строку на 'Change first line from github'
Оба изменения коммитим - одно в локальном, другое в удаленном репо - и пытаемся сделать git push, что выдает уже знакомую ошибку по поводу различия в репозитриях. Пытаемся решить проблему командой git pull, после чего появляется сообщение о наличии конфликта: CONFLICT (content): Merge conflict in <filename>. Automatic merge failed; fix conflicts and then commit  the result.
Команда git status выдает следующее сообщение:
On branch master
Your branch and 'origin/master' have diverged,
and have 1 and 1 different commits each, respectively.
  (use "git pull" to merge the remote branch into yours)

You have unmerged paths.
  (fix conflicts and run "git commit")
  (use "git merge --abort" to abort the merge)

Здесь есть несколько вариантов решения проблемы:
1. отменить изменение командой git merge --abort 
2. решаем конфликт:
2.1. в любом редакторе открываем файл со статусом both modified (у нас это файл some.file)
здесь все конфликтующие участки файла находятся в границах, отмеченных маркерами, например, так:

<<<<<<< HEAD
Line from terminal
=======
Line from github
>>>>>>> 72f38e567064893ff2d1657abd498a7fdc615ff9

Для решения конфликта надо убрать все эти маркеры (и в этом случае git будет считать, что конфлиет исчерпан)  
Сделаем так - оставив оба варианты изменения файла и просто удалим все маркеры,  т.е. получим (будет ли потом работать такой код, здесь неважно):

Line from terminal
Line from github

После изменения, сохранения и закрытия файла делаем git add <filename>, далее git status и видим, что 
All conflicts fixed but you are still merging.
  (use "git commit" to conclude merge)

Changes to be committed:
	modified:   some.file

Чтобы закончить эту тему, надо сделать мерджевый коммит (коммит слияния): git commit -am "merge | resolve conflict"

git status:
On branch master
Your branch is ahead of 'origin/master' by 2 commits.
  (use "git push" to publish your local commits)

git push
Конфликт решен

Команда git checkout <filename> возвращает файл к состоянию, в котором он был до изменения (но до коммита дело еще не дошло, т.е. файл не коммитили), т.е. на момент последнего коммита. Для отмены изменений всех файлов директории используется вариант git checkout .

Для временного изъятия изменений используется команда git stash. При этом изменения будут скрыты, но не удалены (мы возвращается к состоянию чистого коммита). Для того, чтобы достать и вернуть спрятанные изменения, пишут git stash pop
Можно удалить  изменения из stash, для этого используем git stash clear

ВЕТКИ
git branch my_first_brahcn - создаем ветку my_firsh_branch
Команда git brabch выводит список веток (символ * показывает, на какой ветке мы сейчас находимся)
Для переключения на новую ветку используем команду git checkout my_first_branch
Вносим изменения в файл и коммитим его: git commit -am 'first commit to new branch'
Пытаемся сделать git push и получаем ошибку 'fatal: The  current branch my_first_branch has no upstrean branch.', т.е. удаленный репо ничего не знает о создании и существовании локальной ветки.  Для избежания этого надо не забывать при первом пуше указывать необходимый ключ, пишем: git push -u my_first_branch
Возврат в предыдущую ветку: git checkout -

Мерджим ветку в мастер. Прежде всего, надо находиться в ветке, куда мы хотим влить изменения (это можно проверить, например, командами git status и git branch)
Для мерджа пишем: git merge my_first_branch (на этом этапе изменяется лишь локальная ветка master). Для того, чтобы изменения увидели все, пишем git push. Теперь операция слияния веток закончена: ветка my_first_branch влилась в master.
 
Если за то время, когда мы разрабатываели свою  ветку, в удаленный репозиторий были внесены изменения (т.е. были сделаны какие-то коммиты кем-то еще, кто работает над этим проектом) создается ситуация, когда мы отстаем от удаленного репозитория на число сделанных коммитов.
git branch branch_for_new_file - создаем ветку
git checkout branch_for_new_file - переходим на созданную ветку
echo 'Hello from new file' > new.file - создаем файл в этой ветке
git add new.file - добавляем этот файл в список отслеживаемых файлов
git commit -am 'add new.file' - коммитим этот файл 
git push -u origin branch_for_new_file - пушим ветку на удаленный репо
git checkout master - возвращаемся в ветку master
git  marge branch_for_new_file - сливаем в ветку master ветку branch_for_new_file в локальном репо
git push - пытаемся отправить наши изменения на удаленный репо и получаем ошибкуerror: failed to push some refs ... Updates were rejected because the remove contains work that you do not have locally...
git pull - стягиваем изменения с удаленного репо
git push  - у нас появляется мерджевый коммит, т.е. проблема решена

Если работа ведется в разных ветках, но над одним и тем же файлом, делаем все то же самое, но еще разрешаем конфликт в общем файле.

Переименование ветки делается так: git branch -m <oldname> <newname>
Если ветка уже добавлена на удаленный репо (т.е. в origin), то делаем так:
надо удалить запушенную ветку со старым названием на удаленном репо командой git push origin :<name_of_branch>; должна появиться информация о том, что ветка удалена: - [deleted] <name_of_branch> и теперь пушим новую ветку, словно это в первый раз: git push -u origin <new_name_of_branch>
Важно: перед удалением удаленной ветки надо стянуть с нее все ее изменения, иначе они будут потеряны (что логично)
Удаление ветки осуществляется командой git branch -d <branchname>
Стянуть в локальный репозиторий из удаленного репозитория ветку, которой у нас еще нет, можно командой: git fetch origin <branchname>
Для того, чтобы увидеть эту стянутую ветку, надо на нее переключиться командой: git checkout <name of branch, that have fetched from origin>

Откатить от add до untracked для какого-то файла можно так: git reset HEAD <filename>
Сделать это для всех добавленных файлов можно так: git reset HEAD .
Удалить все untracked файлы можно командой: git clean -f
Сделать то же, но для неотслеживаемой директории, можно так: git clean -f -d
При этом, имя директории не указывается, так как подразумевается, что речь идет о директории, которая не отслеживается (помечена красным) 
Если в директории есть файл, учтенный в .gitignore, надо убрать этот файл из удаляемой директории. 

Команда git grep позволяет искать по содержимому файла
Пишем git grep <name_of_string_tham_searched>
git grep Line - найдем файл (или файлы?), в которых есть слово Line
git grep -n Line - будут указаны еще и строки, в которых есть это слово
git grep -c Line - будет подсчитано, сколько раз это слово встречается в данном файле
Можно искать и по двум словам (для чего используем ключ -e), например:
git  grep -e something -e Line - т.е. ищем по словам "something" и "Line".
git grep -i line - ключ -i используется для игнорирования регистра
Получить справку по команде можно так: git grep --help

Файл .gitconfig. Он находится в директории пользователя: ~/.gitconfige
Настройки:
[color]
    diff = auto
    status = auto

[color "status"]
    added = yellow
    changed = green
    untracked = blue

[color "diff"]
    old = red bold
    new = green bold

В директории .git хранится вся информация о репозитории
файл .git/config содержит много информации, например, о нашем сервере origin
Мы можем изменить, например, адрес нашей эл. почты, прописав в данной файле в первой строке:
[user]
    email = <указываем тот адрес, который нам надо использовать>

Файл .gitignore содержит паттерны, которые совпадают с файлами, которые мы не хотим видеть в наше репозитории

Псевдонимы для команды git прописываются в cofig-файлах. Здесь будет задавать эти алиасы в файле .gitconfig
[alias]
    co = checkout
    ci = commit
    st = status
    ......

Git flow - схема работы с ветками. Есть две основные ветки: master (на которой идет учет боевой версии) и develop (идет параллельная разработка улучшений рабочей, боевой версии). Между ними есть еще ветки: feature - разработка фичей в орбите ветки develop, release - добавление разработок в боевую версию, hotfix - исправления багов в боевой версии.


IvanAkylov

GIT
---
Decentral version control system (DVCS) - распределенная система
контроля версий 

Branches (ветки): Master, Hotfix, Release, Development, Feature

Commit - точка сохранения проекта

Три этапа:
#1 Working with files - File changes
#2 Add tp staging area - Caching files
#3 Repository - Commit

Repository - хранилише, куда помещаются файлы проекта
обязательно  наличие скрытой папки .git

Установка git с сайта git-scm.com

Проверка версии: git --version

Вывод списка команд: git


Создание локального репозитория и сохранение его содержимого
------------------------------------------------------------
1. Создаем новый проект или берем существующий проект
2. Переходим в корневую папку проекта
3. Вводим команду git init
Как подтверждение создания - появление папки .git

4. Проверяем состояние содержимого репозитория: git status
Должны быть выведены названия неотслеживаемых файлов

5. Добавляем выделенные файлы в репозиторий: git add .
Символ "." означает, что будут записаны все эти файлы

6. Опять проверяем состояние содержимого: git status
На этот раз указанные файлы должны оказаться учтенными

7. Теперь сохраним изменения в содержимом репозитория:
git commit -m "Initial commit" (флаг ставится специально для
того, чтобы сделать комментарий)

8. Смотрим записи о коммитах в репозитории: git log
Для выхода из лога надо нажать q

Т.о., внесение любых изменений можно рассматривать как связку:
git add - git status - git commit - git - log


Работа с ветками репозитория
----------------------------
1. Создаем файл .gitignore, где указываются расширения файлов и т.п., 
что нежелательно коммитить в репозиторий проекта
Образцы можно взять на github.com/IvanAkulov/gitignore
Кладем  этот файл в корень проекта

2. Создаем репозиторий на основе проекта: git init

3. Создаем новую ветку (например, с именем bugFix#100): git branch bugFix

4. Проверяем ветки: git branch (должно вывести master и bugFix)

5. Переходим на ветку bugFix#100: git checkout bugFix\#100
(экранируем знак решетки???)
Создание и переход на ветку можно сделать командой: 
git checkout -b newFeature (флаг обозначает создание новой ветки)

6. Удаление ветки репозитория: git branch -d newFeature
(для осуществления процесса удаления надо находиться вне этой ветки)

7. Сливаем ветки (на основе master):
7.1. переходим на ветку master: git checkout master 
7.2. сливаем код ветки master с веткой bugFix#100: git merge bugFix#100 


Работа с удаленным репозиторием
-------------------------------
1. Создаем аккаунт на сайте github.com

2. Создаем новый репозиторий (кнопкой New repository):
Опционально можно инициализировать README.md файл, создать папку .gitignore
и добавить лицензию

3. После нажатия кнопки Create repository необходимо связать созданный
удаленный репозиторий с локальным репозиторием. Для этого со страницы
сайта копируется код: 
3.1. устанавливаем связь между репозиториями: git remote add origin github.com/.../xxx.git
3.2. переносим содержимое с локального репозитория на удаленный: git push -u origin master

4. Вносим изменения в содержимое удаленного репозитория и коммитим это кнопкой
(опционально есть возможность сделать это в мастер-ветке или завести новую)

5. Подтягиваем эти изменения на локальный репозиторий: git pull 

6. Можем создать новую ветку на удаленном репозитории кнопкой и перейти на нее
в командной строке из локального репозитория: git checkout <name of branch>

7. Можем осуществить клонирование репозитория с сервера на комп: 
clone repository <абс. путь до удаленного репозитория>
Для обратного процесса следует применять команду git push


Разрешение конфликта при слиянии двух веток, ссылающихся на один и тот же файл
------------------------------------------------------------------------------
1. Вызываем методы разрешения конфликта: git mergetool
2. Выбираем метод opendiff: он активирован по умолчанию (просто жмем кнопку Enter)

Когда мы работаем на дочерней ветке, то для того, чтобы соединить нашу ветку 
с мастер-веткой, надо сделать Pull request (кнопкой на Githube). Если в команде есть
еще разработчики, то они должны согласиться на такое слияние


Полезное (правильность команд не подтверждена!!!)
--------
1. Команда git diff выводит построчные изменения в файле (подсвечивает красным и зеленым)

2. Команда git checkout <имя файла> отменяет сделанные изменения

3. Графическое представление конфигурации веток: git log --oneline --graph --decorate --all

4. Запрос информации о конфигурации системы контроля версий: git config --global --list

4.1. Смена текущего пользователя: git config --global user.name "Name"

4.2. Изменение пароля пользователя: git config --global user.email "xxx@gmail.com"

git config --edit --global - посмотреть и отредактировать файл с настройсками аккаунта


ILYIA KANTOR
------------
git rm --cached <filename> - удалить файл из предбанника, но оставить в рабочем каталоге

git rm -f <filename> - удалить файл несмотря ни на что

git config core.editor - вывод на экран основного редактора 

Для меня - это 'c:/program files (x86)/sublime text 3/sublime_text.exe' -w


ВЕТКИ

Ветка - это изолированный поток разработки, в котором можно делать коммиты так, что их не видно из других веток

git brach - показать ветку

git branch -v - показать ветку и информацию о коммите, на который она указывает 

файл HEAD хранит ссылку на текущую ветку (вначале это master)

git branch <branch name> - создать ветку с именем <branch name>

ветка - это просто ссылка на коммит

git checkout <branch name> - перейти на ветку <branch name>

git checkout master - переход на ветку мастер (команда изменит ссылку на текущую ветку в HEAD и перенесет в 
						рабочую директорию файлы проекта из ветки master)

git checkout -b fix - создает ветку с названием fix и сразу же переходим на нее (флаг -b)

git checkout -f master - принудительно переключит на другую ветку, если даже есть незакоммиченные изменения 
		(но при этом все, что было незакоммичено в ветке, с которой пришлось уйти, пропадет)

git checkout -f - эта команда (без аргументов или с аргументом HEAD) отменяет незакоммиченные изменения

git stash - собирает незакоммиченные изменения, удаляет их из файлов и в специальном виде архивирует в Git

git stash pop - вернуть незакоммиченные изменения

Может возникнуть ситуация, что stash был применен на одной ветке, а потом выгружен в другую ветку, что
		может привести к конфликту

git branch -f master 54a4 - принудительно создаст уже существующую ветку master путем перемещения к коммиту 
	с идентификационным номером 54а4..., т.е. сделает откат назад (при этом с ветки сначала надо уйти)

git branch -f master fix - ветка master будет указывать на тот же коммит, что и ветка fix в данный момент

git checkout -B master 54a4 - то же самое, что и git branch -f master 54a4

Для чего это: если были сделаны ошибочные коммиты в ветке мастер, то откат назад вернет ветку на верную
дорогу, а ошибочные коммиты останутся на ветке fix

Detached HEAD - ситуация "отделенная HEAD", когда в HEAD находится не ссылка на ветку, а ссылка на коммит,
т.е. теперь коммиты будут сами по себе, вне какой-либо ветки разработки

git cherry-pick <id of commit or commits> - скопирует бесхозные коммиты на текущую ветку

git checkout 54a4 index.html - откат до прежнего коммита только файла index.html (в качествве аргументов 
                              можно передать несколько файлов и/или каталогов)

git checkout <filename> - возвращает файл из предбанника в рабочую территорию

git checkout HEAD <filename> - возвращает файл из репозитория в предбанник и в рабочую территорию

git checkout -- master - двойной дефис помогает переключаться на каталог с неоднозначным названием, например,
'master' (т.е. каталог с названием, совпадающим с названием ветки), и если есть флаги и аргументы, то они
ставятся до этого двойного дефиса

git log - список коммитов

git log --oneline - список коммитов в лаконичной форме

git log master - список коммитов в ветке master

git show <HEAD, название ветки или id коммита> - выводит информацию о коммите

git show HEAD~ - информация о коммите-родителе настоящего HEAD (~~ - информация о родителе родителя;
				количество тильд можно заменять числом, т.е., например, HEAD~3)

git show HEAD --quiet - информация о коммите в лаконичной форме

ВМЕСТО HEAD можно использовать знак @

git show master~2 - информация о коммите за два шага до HEAD в ветке master

git show @~2:index.html - посмотреть весь файл целиком в текущей ветке в коммите за два шага от HEAD

git show fix~2:index.html - то же, но в ветке fix

git show :index.html - посмотреть текущею версию, находящуюся в предбаннике

git show :/<слово из файла> - вернется самый свежий коммит, содержащий это слово

git merge fix - находясь в ветке master, осуществляем ее слияние с веткой fix (переносимся при этом
с HEAD ветки master на HEAD ветки fix, т.е. HEAD ветки master получает номер коммита в HEAD ветки fix)

git branch -f master ORIG_HEAD - откатывает изменения в ветке master на шаг назад

git branch -d fix - удаление ветки fix

git branch -D feature - принудительное удаление ветки feature

git reflog - вывести информацию из рефлога о коммитах для HEAD; это нужно, например, для восстановления веток:
			команда git branch feature HEAD@{6} восстановит ветку featurе по состоянию HEAD{6}

git reflog master - то же самое, отдельно по ветке master

git branch feature HEAD@{37} - воссоздать ветку feature по состоянию на шаг 37 согласно рефлогу коммитов

git reflog --date=iso - выводит даты осуществленных коммитов

git branch feature HEAD@{<Дата осуществления коммита>} - так же воссоздает ветку, но по дате

git reflog --no-decorate - выводит список коммитов без показа дополнительных ссылок

git checkout @{-1} - переключиться на предыдущую ветку

git fsck --unreachable - выводит список недостижимых коммитов

git reflog expire --expire=now --all - удаляет данные из рефлогов (т.е. чистит рефлоги)

git gc --prune=now - удаляет все коммиты, моложе чем сейчас (непонятно)


ТЭГИ

git tag v1.0.0 1913 - создает тег для конкретного коммита, может использоваться для
			идентицифации коммита без задействования его id

git tag -a v.1.1 1915 - создает тег с аннотацией (вызывает редактор)

git show v1.0.0 --quiet - просмотр краткой информации о коммите

git tag --contains 45a4 - посмотреть, какой тег имеет коммит 45a4

git tag -n - вывести информацию о тегах

git tag -d <имя тега> - удаление тега

git describe 1913 - описание коммита по имени ближайшего тега (выведет v1.0.0)

git archive -o /tmp/v.10.0-<номер ближайшего коммита>.zip HEAD - создание архива
			коммита (версии релиза) на базе тега


RESET

git reset @~ - вернуться на предыдущий коммит

git reset 12345 - вернуться на коммит 12345

git reset --hard 12345 - жесткий reset переводит HEAD в позицию коммита 12345 и обновляет
состояние рабочей директории и предбанника так, чтобы они соответствовали состоянию репозитория

git reset --hard HEAD - если изменения внесены в предбанник, но еще не закоммичены, и надо
откатить назад - выполняем эту команду

git reset --soft - переносит только HEAD, а рабочую директорию и предбанник не трогает

Мягкий reset нужен для того, чтобы внести изменения в неудачный коммит

git commit -C ORIG_HEAD - коммит с id предыдущего коммита (-с - откроется редактор для 
написания комментария, -С - сохранится описание предыдущего коммита)

git commit -C ORIG_HEAD --reset-author - поставить в коммите свои данные, а не данные
автора коммита, на основе которого производится данный коммит

git reset --amend - производит мягкий reset и создает новый коммит

флаг --no-edit отменяет вызов редактора

в отличие от --amend мягкий reset дает возможность откатиться более, чем на один уровень
назад, после чего их можно объединить в один коммит (просто закоммитить)

git reset --mixed - смешанный reset, обновляющий предбанник и репозиторий, но не 
трогающий домашнюю директорию

git reset HEAD - очищает предбанник от изменений, если мы необдуманно сделали git add smth

git reset index.html - смешанный reset позволяет сбросить изменения конкретного файла,
иными словами это команда-антипод для git add (одна добавляет - другая удаляет)

git reset 54a4 index.html - будет произведен откат файла до коммита 54а4 (но HEAD останется
на месте!), однако для этого есть команда git checkout 54а4, которая помещает версию не
только в предбанник, но и в рабочую директорию

git reset --keep - если нет незакоммиченных изменений, работает как жесткий reset, а если
есть - сохраняет их в рабочей директории

git reset --merge - отмена неудачного конфликтного слияния, удаляет изменения, которые внесены
в предбанник. Если есть незакоммиченные изменения и они проиндексированы (в предбаннике
, т.е. уже прошли через git add), то они будут полностью удалены 

Все reset-ы передвигают текущую ветку на указанный коммит

git help reset - много интересной информации


ОЧИСТКА РЕПОЗИТОРИЯ ОТ ВСЕГО ЛИШНЕГО (ФАЙЛОВ)

git clean -dxf - удаляет неотслеживаемые файлы (с флагом -d будут удаляться и директории,
с флагом -x будут удаляться файлы, игнорируемые через .gitignore, а без флага -f
все это не будет работать)


ПРОСМОТР ИНФОРМАЦИИ
	
git diff - используется для сравнения коммитов и файлов путем передачи их id или ссылок
на ветки (например, 45a4 и 47d7 или веток master и feature)

git diff master...feature - покажет, что именно изменилось (непонятно)

git diff 54a4 - можно передать и один коммит, при этом будет произведено сравнение
рабочей директории с данными этого коммита в репозитории

git diff -U0 master feature index.html - покажет только изменения (-U0) в файле, 
					т.е. без общих строк

git diff HEAD - покажет изменение в рабочей директории с момента последнего коммита
(т.е. сравнит содержимое рабочей директории и коммита, который находится в HEAD)

git diff HEAD~2 - сравнит последний коммит с предпредпоследним

git diff HEAD~2 HEAD~1 - сравнит предпредпоследний коммит с предпоследним коммитом

git diff - конкретно эта команда сравнивает содержимое рабочей директории и предбанника

git diff --cached - покажет изменения, которые проиндексированы, но еще не в репозитории 
			(т.е. сравнивает содержимое предбанникаи и репозитория)

git diff index.html - покажет изменения в конкретном файле

git diff --name-only master feature - покажет только пути различаемых файлов в этих
					каталогах

git diff --name-only HEAD~3 - покажет имена файлов, измененных в коммите, находящемся за три коммита от HEAD (так же можно вместо HEAD подставить хэш коммита)

git diff @ - посмотреть, что мы сделали с момента последнего коммита

git diff -- master - передать путь к каталогу или файлу с названием master

git diff --no-index - работает изолированно от репо и сравнивает вообще два любых файла
			на диске

git diff --word-diff - показать отличие по словам (удобно при анализе текстовых файлов)

Создать файл .gitattributes и записать в нем строку *.html diff=html для того, чтобы 
правильно осуществлялась обработка содержимого по регулярным выражениям с учетом формата файла

git log --pretty=medium - это значение по умолчанию (соответствует git log)

git log --oneline - сокращенный вывод информации

git log pretty=format: '%h %cd | %s%d [%an]' - кастомизированный вывод информации:
%h - сокращенный идентификатор коммита, %cd - дата, %s - заголовок коммита, 
%d - декорирование (т.е. какие ссылки указывают на коммит) и [%an] - автор коммита

git hist - графическое отображение структуры репозитория

git log index.html - покажет коммиты, в которых изменялся файл index.html

git log --grep Run - выводит список коммитов, где есть слово Run в текущей ветке
		(но можно передать имя любой ветки)

git log --grep Run --grep sayHi - выводит список, где есть либо первое слово, либо второе

git log --grep sayhi -i - производит поиск без учета регистра 

git log --grep Run --grep sayHi --all-match - выводит список, где есть оба слова 

git log --grep 'say(Hi|Bye)' -P - включаются перлосовместимые РЕ (без флага не сработает)

Для активации перлосовместимых РЕ можно ввести команду настройки:
git config --global grep.patternType perl

git log -F - отключение РЕ (поисковая строка будет воприниматься как обычный текст ?!)

git log -G'sayHi' - выведет список коммитов, в коде файлов которых есть изменения 
строки 'sayHi' (флаг -p выведет фрагменты файлов с изменениями строки 'sayHi')

git log -G'function sayHi \(' - скобки, как спец. символы, надо экранировать

git log -L 3,6:index.html - выведет все коммиты, где есть изменения в файле index.html
		в диапазоне с 3 по 6 строки
git log -L '/head>/','/<\/head>/':index.html - то же, но поиск производится по РЕ

git log -L '/^function sayHi/','/^}/':index.html - ищем функцию sayHi

git log --author=<username> - поиск по автору коммита (или по коммитеру - флаг --commiter)

git log --before '2019-28-03' - поиск по дате (и по времени - 08:25:12), есть флаг --after

git blame index.html - посмотреть, кто именно написал каждую строку в файле


СЛИЯНИЕ

git merge-base master feature - покажет коммит, на котором ветки разделились

base - общий коммит (где ветка feature отошла от ветки master)

our - наш последний коммит (HEAD), мы на ветке master

their - последний коммит на ветке feature

Таким образом: base + (our changes) + (their changes) -> merge

cat .git/MERGE_HEAD - посмотреть id коммита из ветки feature, с которым будет
			произведено слияние 

<<<<< HEAD

версия кода из ветки master

========

версия кода из ветки feature

>>>>>>>

git checkout --ours index.html - возьмут вариант файла из нашей ветки (из HEAD)

git checkout --theirs index.html - возьмут вариант файла из ветки feature

git reset --hard - такой командой можно отменить слияние

git reset --merge - оставляет незакоммиченные изменения в файлах, которые 
			не участвовали в слиянии

git merge --abort - делает то же самое, что и команда выше

git checkout --conflict=diff3 --merge index.html - выводит информацию не только
о конфликтующих версиях файла, но и версии из последнего общего коммита 
(того, от которого и пошли эти ветки): в коде появится фрагмент, выделенный так:
||||||| base

Такое отображение конфликта (base - ours - theirs) можно задать в настройках:
git config --global merge.conflictStyle diff3()

Эти версии можно посмотреть так (base - 1, ours - 2, theirs - 3):
git show :1:index.html - посмотреть базовую версию файла index.html и т.д.

После разрешения конфликта файл надо добавить в предбанник:
git add index.html
Далее его надо закоммитить: git merge --continue (или же просто git commit)
Тут же откроется файл для записи комментария коммита

git log --oneline --all --graph - выведет схему веток в репозитории

git show --first-parent - посмотреть отличие текущего варианта файла от того,
				что было у первого родителя

git show -m - покажет отличие от всех родителей по отдельности

git HEAD^ - покажет отличия от первого родителя

git HEAD^2 - покажет отличия от второго родителя

git HEAD^^ - покажет отличия от первого родителя первого родителя

git merge feature --log=5 - при слиянии в комментарии будут добавлены
описания 5 предыдущих коммитов с ветки feature (если написать просто --log,
то будут добавлены все описания, но не более 20)

git log master --oneline --first-parent - список коммитов только по 
первому родителю (т.е. по ветке master)

git commit --no-edit - коммит без написания комментария

git megre --no-ff - вместо перемотки делать делать коммит слияния

git config merge.ff false - отключить функцию перемотки

git merge --ff feature - явно включить функцию перемотки в ветке feature

git merge --squash fix - берет изменения из ветки fix и применяет их 
к текущему состоянию проекта, т.е. к рабочей директории и предбаннику
Далее делаем коммит - в итоге изменения упакованы в самый обычный коммит,
без всякой связи с веткой, из которой они были взяты


КОПИРОВАНИЕ КОММИТОВ

git cherry-pick D - находясь на ветке master, копируем с ветки feature коммит D,
создавая эквивалентный коммит D'
Принципиальное отличие cherry-pick от слияния - слияние копирует ветки целиком,
а cherry-pick скопирует только указанный коммит

git cherry-pick master...feature - копировать все коммиты из feature, которых нет 
					в master

В ходе копирования при возникновении конфликта можно ввести команды:

git cherry-pick -- abort - отменит уже скопированные коммиты и вернет все 
				в первоначальное состояние

git cherry-pick --continue - продолжит копирование (предварительно решив конфликт)

git cherry-pick --quit - остановиться там, где мы сейчас, и сбросить запомненное состояние
(какие коммиты уже были скопированы, а какие нет). 

git reset --hard @~ - отменить копирование одного коммита (или если n коммитов, то @~n)

git cherry-pick -n 54a4 - скопировать изменения из коммита 54а4 (с тем, чтобы их немного 
подредактировать), но без коммита (изменения будут в предбаннике, но не закоммичены)

git cherry master feature - сравнение веток master и feature на наличие эквивалентных коммитов
(например, возникших в результате копирования): выведет коммиты со знаками '-' - в ветке 
feature есть копия в master, а '+' - нет копии

git log --oneline feature...master - выводит симметрическую разность коммитов 
(флаг --cherry-mark помечает эквивалентные коммиты знаком '=',
а флаг --left-right - знаками '>' и '<' покажут, какой коммит из какой ветки,
в нашем случае '>' - это master, a '<' - feature)


RERERE

rerere = REuse REcorded REsolution (авторазрешение повторных конфликтов)

git config rerere.enabled true


ОБРАЩЕНИЕ КОММИТОВ

git revert @ - смотрит, какие изменения сделаны в указанном коммите (например, текущем)
		и создает коммит с противоположными изменениями

Добавление удаленного репозитория в локальный репозиторий с использованием ssh-ключа- git remote add origin git@github.com:karyshev63rus/test_ssh_key.git

Переход формата связи между репозиториями от https к ssh можно сделать так:
1) git remote remove origin - удаляем связь между репозиториями
2) git remote add origin git@github.com:karyshev63rus/test_ssh_key.git - добавляем удаленный репозиторий через новый формат связи

git remote -v - информация об удаленном репозитории, связанном с локальным репо (который находится в текущей папке)

удалить нежелательный коммит, который уже залит на github, можно так:
1. заходим в папку репозитория
2. выясняем id коммита, до которого нужно откатиться (скорее всего, это предыдуший коммит), пусть это будет asd1231324
3. вводим команду git reset --hard asd1231234 (git скажет, что произведен откат до коммита asd1231324)
4. вводим команду git push --force (насильно отправляем свои изменения на отдаленный репо и перетираем там коммиты, уже удаленные к этому времени на локальном репо). Опасная операция - если  репо общий, можно случайно удалить чужой код как  результат общей работы.

История про два аккаунта git.hub с доступом по ssh-ключам с одного и того же компьютера

git branch -M main - переименует главную (или текущую?) ветку в main
git branch -M master - соответственно, в master

Удаление папки из удаленного репо с сохранением ее в локальном репо
git rm -r --cached FolderName
git commit -m "Removed folder from repository"
git push origin master

ОТМЕНЫ И ОТКАТЫ skillbox
------------------------
git rm --cached <filename> - отмена внесения файла в индекс и возвращение его в unstaged

git restore --staged <filename> - откат файла из индекса в доиндексное состояние

git checkout -- <filename> - отмена изменений в файле до команды git add, т.е. до внесения файла в индекс

git reset HEAD <filename> - откат назад в доиндексное состояние после команды git add, но до команды git commit

git commit --amend - изменить последний коммит. Как это делается:
1. вносим изменения в код
2. добавляем измененния в индекс командой git add .
3. вызываем команду git commit --amend, после чего открывается редактор, где можно внести изменения в название коммита или оставить его прежним. В итоге последние изменения будут внесены в данный коммит.
 
git revert <хэш коммита> - откат к коммиту с данным хэшом, но эта команда тоже будет сопровождаться коммитом, который возглавит всю историю коммитов (т.е. никакие коммиты из истории удалены не будут, просто передовой коммит будет идентичен тому коммиту, к которому был сделан откат). 

git reset --hard <хэш коммита> - сброс истории коммитов до указанного коммита, т.е. с потерей всех изменений (жесткий вариант)

git reset --hard - команда очистит рабочую директорию git, т.е. будет сброшена история изменений (уже попавших в индекс или еще нет) до головы данной ветки

git reset --soft <хэш коммита> - все, что выше этого коммита, добавляется в индекс, т.е. изменения не исчезают и могут быть позднее закоммичены

git reset <хэш коммита> - все коммиты, позднее данного, должны быть "срезаны", а изменения должны попасть в unstaged (т.е. в доиндексное состояние) 

git reset --mixed HEAD <filename> - вывести файл из индекса в unstaged (команда reset --mixed HEAD соответствует команде reset HEAD)

git commit -a -m 'message' - команда добавления в коммит минуя git add


ВЕТКИ skillbox
--------------
git checkout -b dev - создаем и переходим в ветку dev

git push -u origin dev - отправляем в удаленный репо в ветку dev
git push -u origin master - то же, но в ветку master

git remote - просмотр всех удаленных репо для данного локального репо (?)
git remote -v - то же, но с адресами этих репо

git branch -m dev develop - переименовываем ветку из dev в develop

git branch -l - список веток

git branch -d develop - удаление ветки develop (но перед этим надо уйти с удаляемой ветки)

git push --delete origin dev - удаление ветки dev на удаленном репо

git diff master..develop - сравнение веток

Сравнение одноименных веток локального и удаленного репо, например, веток master:
1. git fetch - получаем данные из удаленного репо
2. git diff master..origin/master - производим сравнение

git merge develop - слияние ветки develop с текущей веткой, например, с веткой master


ПОЛЕЗНЫЕ ИНСТРУМЕНТЫ skillbox
-----------------------------
git stash - как работает в командной строке непонятно, ибо не объяснили, но смысл в том, что можно часть кода сохранить без обращения к git, а потом командой unstash достать обратно

git blame <filename> - просмотр авторов коммитов

git gc - команда приводит репо в порядок (похоже, что gc - это garbare collector)

git push origin -d <name_of_branch_that_need_to_delete> - удалить ветку из удаленного репо

ДАЛЕЕ ИЗ РАЗНЫХ ИСТОЧНИКОВ
--------------------------
переместиться в прошлое, т.е. посмотреть состояние репо на уровне одного из сделанных ранее коммитов можно командой git checkout <хэш коммита>, а чтобы вернуться обратно - gjt checkout master (или на какой ветке все это происходит)


GITLAB
=======

Установка и работа с gitlab-runner на сервере
---------------------------------------------

1. Добавляем репозиторий в систему 
curl -L "https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh" | sudo bash

2. Устанавливаем пакет
sudo apt unstall gitlab-runner

3. Регистрируем раннер
sudo gitlab-runner register 
Далее вставляем URl и token с сайта, а также выбираем из предложенного списка способ выполнения команд (это будет shell)

4. Верифицируем раннер
sudo gitlab-runner verify

5. На сайте создаем или модифицируем файл gitlab-ci.yml, где прописываем те задачи, которые должен будет выполнить раннер. Сохраняя изменения, мы фактически запускаем созданный раннер. Результаты его работы можно посмотреть в pipline или jobs опции CI/CD в левой боковой панели.

Конфиг раннера лежит по пути /etc/gitlab-runner/config.toml и выглядит примерно так (в нем обязательно должны быть указаны данные привязанного и активного раннера, иначе ci работать не будет - соответствующая job впадет в состояние stuck):

concurrent = 1
check_interval = 0
[session_server]
  session_timeout = 1800
[[runners]]
  name = "googlec"
  url = "https://gitlab.com/"
  token = "V-aTXW6oFeGmeTns6GzA"
  executor = "shell"
  [runners.custom_build_dir]
  [runners.cache]
    [runners.cache.s3]
    [runners.cache.gcs]
    [runners.cache.azure]


Команды cli для gitlab-runner:

gitlab-runner list - список раннеров, установленных на сервере

