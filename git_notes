Git - инструменты тестировщика (Арсений Батыров)
------------------------------------------------

Создаем файл конфигурации .gitconfig, куда прописываем:
[user]
    email=karyshev63rus@gmail.com
    name=karyshev63rus
Просмотр конфигурационного файла: git config --list --global

Далее создаем репозиторий на github и клонируем его на машину: git clone <ссылка на удаленный репо>
Создаем файл и пишем в него одну строку
Проверка статуса с целью выявить неотслеженные файлы: git status (красный)

Добавление неотслеженного файла куда-то там (в stage?): git add <filename>
еще раз проверка статуса: теперь файл зеленый

Дописываем еще одну строку и проверяем статус: файл теперь и зеленый (new file), и красный (modified) - здесь мы можем либо откатить изменения назад,т.е. отказаться от модификации (git checkout -- <filename> или git restore <filename>), либо добавить изменения командой git add <filename>

Фиксируем новое состояние проекта командой git commit -m init "my first commit"

Смотрим на изменения в удаленном репо. Они есть. Изменяем файл на удаленном репо и возвращаемся к локальному репо, проверяем его состояние: git status. Никаких изменений не видно, так как они были сделаны не через локальный репо

Для получения информации об изменениях на удаленном репо набираем git fetch
и далее git status - видим, что локальный отстает на один коммит

Версии веток:
master - это локальная рабочая ветка (Клиент, ветка расположена на нашей машине)
origin master - это версия ветки на удаленном репозитории (Сервер, - на сервере)
origin/master - это тоже локальная, но нерабочая версия ветки (в ней хранится та информация, которую мы знали об удаленном репозитории на момент последнего выполнения команды git fetch). Она нужна для того, чтобы понять, в каком состоянии находится наша локальная ветка относительно origin ветки. Когда делается git fetch, именно в эту ветку поступает информация о состоянии origin master. Наша ветка master при этом никак не меняется.
Важно помнить, что master - это только одно из имен ветки. Если наша локальная ветка называется, к примеру, "test", то ветка на сервере будет "origin test",а локальная ветка для git fetch будет называться "origin/test".

Стратегия fast-forward - по сути это одна из стратегий слияния локальной и удаленной веток проекта. Предположим, что в мастер-ветке (на удаленном репо) у нас был коммит А. Мы внесли какие-то изменения и сделали коммит С в нашем локальном мастере, но в это время в origin уже кто-то добавил какие-то другие изменения в виде коммита В., т.е. сложилась конфигурация А-С и А-В. Если компоненты коммитов В и С никак не мешают друг другу и могут быть представлены в конфигурации А-В-С, то git выбирает стратегию Fast forward, просто меняя предка для С с А на В.

Соглашаемся на предложенную системой стратегию и выполняем команду git pull, после чего выводится информация о том, какие файлы и в каком объеме были изменены. В частности, пишется, например, такое: "Updating 757d1ef..e534f31" - каждый раз,когда мы что-то коммитим, формируется хэш-коммит (хэш - это набор символов,который уникален для каждого коммита в данном репозитории).
Существует команда, которая показывает историю всех изменений нашего репозитория- это git log

Посмотреть историю коммитов, сделанных определенным пользователем: 
git log --author <username>
Команда, позволяющая посмотреть изменения, сделанные в конкретном коммите: 
git show <хэш коммита>
название файла до коммита: --- /dev/null (если только что создали, то оно будет dev/null)
Название файла после коммита: +++ b/some.file`
Между значками @@ будут указаны строки, которые затронули изменения, например, 
@@ -0,0 +1,2 @@
Ниже идет содержимое файла. Знаком "+" показывается строка, которая была добавлена, а со знаком "-" - которая была удалена
Если выполнить git show без указания хэша, то будет выведена информация по последнему коммиту

Посмотреть авторов файла можно при помощи команды git blame <filename>
Автора конкретной строки выявляем так: git blame <filename> | grep <string> 
Поиск по автору: git blame <filename> | grep <username>
Вывести все строки конкретного коммита: git blame <filename> | grep <hash>

Команда git diff выводит изменения файла с момента последнего коммита(?), этот вывод похож на результат команды git show










IvanAkylov

GIT
---
Decentral version control system (DVCS) - распределенная система
контроля версий 

Branches (ветки): Master, Hotfix, Release, Development, Feature

Commit - точка сохранения проекта

Три этапа:
#1 Working with files - File changes
#2 Add tp staging area - Caching files
#3 Repository - Commit

Repository - хранилише, куда помещаются файлы проекта
обязательно  наличие скрытой папки .git

Установка git с сайта git-scm.com

Проверка версии: git --version

Вывод списка команд: git


Создание локального репозитория и сохранение его содержимого
------------------------------------------------------------
1. Создаем новый проект или берем существующий проект
2. Переходим в корневую папку проекта
3. Вводим команду git init
Как подтверждение создания - появление папки .git

4. Проверяем состояние содержимого репозитория: git status
Должны быть выведены названия неотслеживаемых файлов

5. Добавляем выделенные файлы в репозиторий: git add .
Символ "." означает, что будут записаны все эти файлы

6. Опять проверяем состояние содержимого: git status
На этот раз указанные файлы должны оказаться учтенными

7. Теперь сохраним изменения в содержимом репозитория:
git commit -m "Initial commit" (флаг ставится специально для
того, чтобы сделать комментарий)

8. Смотрим записи о коммитах в репозитории: git log
Для выхода из лога надо нажать q

Т.о., внесение любых изменений можно рассматривать как связку:
git add - git status - git commit - git - log


Работа с ветками репозитория
----------------------------
1. Создаем файл .gitignore, где указываются расширения файлов и т.п., 
что нежелательно коммитить в репозиторий проекта
Образцы можно взять на github.com/IvanAkulov/gitignore
Кладем  этот файл в корень проекта

2. Создаем репозиторий на основе проекта: git init

3. Создаем новую ветку (например, с именем bugFix#100): git branch bugFix

4. Проверяем ветки: git branch (должно вывести master и bugFix)

5. Переходим на ветку bugFix#100: git checkout bugFix\#100
(экранируем знак решетки???)
Создание и переход на ветку можно сделать командой: 
git checkout -b newFeature (флаг обозначает создание новой ветки)

6. Удаление ветки репозитория: git branch -d newFeature
(для осуществления процесса удаления надо находиться вне этой ветки)

7. Сливаем ветки (на основе master):
7.1. переходим на ветку master: git checkout master 
7.2. сливаем код ветки master с веткой bugFix#100: git merge bugFix#100 


Работа с удаленным репозиторием
-------------------------------
1. Создаем аккаунт на сайте github.com

2. Создаем новый репозиторий (кнопкой New repository):
Опционально можно инициализировать README.md файл, создать папку .gitignore
и добавить лицензию

3. После нажатия кнопки Create repository необходимо связать созданный
удаленный репозиторий с локальным репозиторием. Для этого со страницы
сайта копируется код: 
3.1. устанавливаем связь между репозиториями: git remote add origin github.com/.../xxx.git
3.2. переносим содержимое с локального репозитория на удаленный: git push -u origin master

4. Вносим изменения в содержимое удаленного репозитория и коммитим это кнопкой
(опционально есть возможность сделать это в мастер-ветке или завести новую)

5. Подтягиваем эти изменения на локальный репозиторий: git pull 

6. Можем создать новую ветку на удаленном репозитории кнопкой и перейти на нее
в командной строке из локального репозитория: git checkout <name of branch>

7. Можем осуществить клонирование репозитория с сервера на комп: 
clone repository <абс. путь до удаленного репозитория>
Для обратного процесса следует применять команду git push


Разрешение конфликта при слиянии двух веток, ссылающихся на один и тот же файл
------------------------------------------------------------------------------
1. Вызываем методы разрешения конфликта: git mergetool
2. Выбираем метод opendiff: он активирован по умолчанию (просто жмем кнопку Enter)

Когда мы работаем на дочерней ветке, то для того, чтобы соединить нашу ветку 
с мастер-веткой, надо сделать Pull request (кнопкой на Githube). Если в команде есть
еще разработчики, то они должны согласиться на такое слияние


Полезное (правильность команд не подтверждена!!!)
--------
1. Команда git diff выводит построчные изменения в файле (подсвечивает красным и зеленым)

2. Команда git checkout <имя файла> отменяет сделанные изменения

3. Графическое представление конфигурации веток: git log --oneline --graph --decorate --all

4. Запрос информации о конфигурации системы контроля версий: git config --global --list

4.1. Смена текущего пользователя: git config --global user.name "Name"

4.2. Изменение пароля пользователя: git config --global user.email "xxx@gmail.com"

git config --edit --global - посмотреть и отредактировать файл с настройсками аккаунта


ILYIA KANTOR
------------
git rm --cached <filename> - удалить файл из предбанника, но оставить в рабочем каталоге

git rm -f <filename> - удалить файл несмотря ни на что

git config core.editor - вывод на экран основного редактора 

Для меня - это 'c:/program files (x86)/sublime text 3/sublime_text.exe' -w


ВЕТКИ

Ветка - это изолированный поток разработки, в котором можно делать коммиты так, что их не видно из других веток

git brach - показать ветку

git branch -v - показать ветку и информацию о коммите, на который она указывает 

файл HEAD хранит ссылку на текущую ветку (вначале это master)

git branch <branch name> - создать ветку с именем <branch name>

ветка - это просто ссылка на коммит

git checkout <branch name> - перейти на ветку <branch name>

git checkout master - переход на ветку мастер (команда изменит ссылку на текущую ветку в HEAD и перенесет в 
						рабочую директорию файлы проекта из ветки master)

git checkout -b fix - создает ветку с названием fix и сразу же переходим на нее (флаг -b)

git checkout -f master - принудительно переключит на другую ветку, если даже есть незакоммиченные изменения 
		(но при этом все, что было незакоммичено в ветке, с которой пришлось уйти, пропадет)

git checkout -f - эта команда (без аргументов или с аргументом HEAD) отменяет незакоммиченные изменения

git stash - собирает незакоммиченные изменения, удаляет их из файлов и в специальном виде архивирует в Git

git stash pop - вернуть незакоммиченные изменения

Может возникнуть ситуация, что stash был применен на одной ветке, а потом выгружен в другую ветку, что
		может привести к конфликту

git branch -f master 54a4 - принудительно создаст уже существующую ветку master путем перемещения к коммиту 
	с идентификационным номером 54а4..., т.е. сделает откат назад (при этом с ветки сначала надо уйти)

git branch -f master fix - ветка master будет указывать на тот же коммит, что и ветка fix в данный момент

git checkout -B master 54a4 - то же самое, что и git branch -f master 54a4

Для чего это: если были сделаны ошибочные коммиты в ветке мастер, то откат назад вернет ветку на верную
дорогу, а ошибочные коммиты останутся на ветке fix

Detached HEAD - ситуация "отделенная HEAD", когда в HEAD находится не ссылка на ветку, а ссылка на коммит,
т.е. теперь коммиты будут сами по себе, вне какой-либо ветки разработки

git cherry-pick <id of commit or commits> - скопирует бесхозные коммиты на текущую ветку

git checkout 54a4 index.html - откат до прежнего коммита только файла index.html (в качествве аргументов 
                              можно передать несколько файлов и/или каталогов)

git checkout <filename> - возвращает файл из предбанника в рабочую территорию

git checkout HEAD <filename> - возвращает файл из репозитория в предбанник и в рабочую территорию

git checkout -- master - двойной дефис помогает переключаться на каталог с неоднозначным названием, например,
'master' (т.е. каталог с названием, совпадающим с названием ветки), и если есть флаги и аргументы, то они
ставятся до этого двойного дефиса

git log - список коммитов

git log --oneline - список коммитов в лаконичной форме

git log master - список коммитов в ветке master

git show <HEAD, название ветки или id коммита> - выводит информацию о коммите

git show HEAD~ - информация о коммите-родителе настоящего HEAD (~~ - информация о родителе родителя;
				количество тильд можно заменять числом, т.е., например, HEAD~3)

git show HEAD --quiet - информация о коммите в лаконичной форме

ВМЕСТО HEAD можно использовать знак @

git show master~2 - информация о коммите за два шага до HEAD в ветке master

git show @~2:index.html - посмотреть весь файл целиком в текущей ветке в коммите за два шага от HEAD

git show fix~2:index.html - то же, но в ветке fix

git show :index.html - посмотреть текущею версию, находящуюся в предбаннике

git show :/<слово из файла> - вернется самый свежий коммит, содержащий это слово

git merge fix - находясь в ветке master, осуществляем ее слияние с веткой fix (переносимся при этом
с HEAD ветки master на HEAD ветки fix, т.е. HEAD ветки master получает номер коммита в HEAD ветки fix)

git branch -f master ORIG_HEAD - откатывает изменения в ветке master на шаг назад

git branch -d fix - удаление ветки fix

git branch -D feature - принудительное удаление ветки feature

git reflog - вывести информацию из рефлога о коммитах для HEAD; это нужно, например, для восстановления веток:
			команда git branch feature HEAD@{6} восстановит ветку featurе по состоянию HEAD{6}

git reflog master - то же самое, отдельно по ветке master

git branch feature HEAD@{37} - воссоздать ветку feature по состоянию на шаг 37 согласно рефлогу коммитов

git reflog --date=iso - выводит даты осуществленных коммитов

git branch feature HEAD@{<Дата осуществления коммита>} - так же воссоздает ветку, но по дате

git reflog --no-decorate - выводит список коммитов без показа дополнительных ссылок

git checkout @{-1} - переключиться на предыдущую ветку

git fsck --unreachable - выводит список недостижимых коммитов

git reflog expire --expire=now --all - удаляет данные из рефлогов (т.е. чистит рефлоги)

git gc --prune=now - удаляет все коммиты, моложе чем сейчас (непонятно)


ТЭГИ

git tag v1.0.0 1913 - создает тег для конкретного коммита, может использоваться для
			идентицифации коммита без задействования его id

git tag -a v.1.1 1915 - создает тег с аннотацией (вызывает редактор)

git show v1.0.0 --quiet - просмотр краткой информации о коммите

git tag --contains 45a4 - посмотреть, какой тег имеет коммит 45a4

git tag -n - вывести информацию о тегах

git tag -d <имя тега> - удаление тега

git describe 1913 - описание коммита по имени ближайшего тега (выведет v1.0.0)

git archive -o /tmp/v.10.0-<номер ближайшего коммита>.zip HEAD - создание архива
			коммита (версии релиза) на базе тега


RESET

git reset @~ - вернуться на предыдущий коммит

git reset 12345 - вернуться на коммит 12345

git reset --hard 12345 - жесткий reset переводит HEAD в позицию коммита 12345 и обновляет
состояние рабочей директории и предбанника так, чтобы они соответствовали состоянию репозитория

git reset --hard HEAD - если изменения внесены в предбанник, но еще не закоммичены, и надо
откатить назад - выполняем эту команду

git reset --soft - переносит только HEAD, а рабочую директорию и предбанник не трогает

Мягкий reset нужен для того, чтобы внести изменения в неудачный коммит

git commit -C ORIG_HEAD - коммит с id предыдущего коммита (-с - откроется редактор для 
написания комментария, -С - сохранится описание предыдущего коммита)

git commit -C ORIG_HEAD --reset-author - поставить в коммите свои данные, а не данные
автора коммита, на основе которого производится данный коммит

git reset --amend - производит мягкий reset и создает новый коммит

флаг --no-edit отменяет вызов редактора

в отличие от --amend мягкий reset дает возможность откатиться более, чем на один уровень
назад, после чего их можно объединить в один коммит (просто закоммитить)

git reset --mixed - смешанный reset, обновляющий предбанник и репозиторий, но не 
трогающий домашнюю директорию

git reset HEAD - очищает предбанник от изменений, если мы необдуманно сделали git add smth

git reset index.html - смешанный reset позволяет сбросить изменения конкретного файла,
иными словами это команда-антипод для git add (одна добавляет - другая удаляет)

git reset 54a4 index.html - будет произведен откат файла до коммита 54а4 (но HEAD останется
на месте!), однако для этого есть команда git checkout 54а4, которая помещает версию не
только в предбанник, но и в рабочую директорию

git reset --keep - если нет незакоммиченных изменений, работает как жесткий reset, а если
есть - сохраняет их в рабочей директории

git reset --merge - отмена неудачного конфликтного слияния, удаляет изменения, которые внесены
в предбанник. Если есть незакоммиченные изменения и они проиндексированы (в предбаннике
, т.е. уже прошли через git add), то они будут полностью удалены 

Все reset-ы передвигают текущую ветку на указанный коммит

git help reset - много интересной информации


ОЧИСТКА РЕПОЗИТОРИЯ ОТ ВСЕГО ЛИШНЕГО (ФАЙЛОВ)

git clean -dxf - удаляет неотслеживаемые файлы (с флагом -d будут удаляться и директории,
с флагом -x будут удаляться файлы, игнорируемые через .gitignore, а без флага -f
все это не будет работать)


ПРОСМОТР ИНФОРМАЦИИ
	
git diff - используется для сравнения коммитов и файлов путем передачи их id или ссылок
на ветки (например, 45a4 и 47d7 или веток master и feature)

git diff master...feature - покажет, что именно изменилось (непонятно)

git diff 54a4 - можно передать и один коммит, при этом будет произведено сравнение
рабочей директории с данными этого коммита в репозитории

git diff -U0 master feature index.html - покажет только изменения (-U0) в файле, 
					т.е. без общих строк

git diff HEAD - покажет изменение в рабочей директории с момента последнего коммита
(т.е. сравнит содержимое рабочей директории и коммита, который находится в HEAD)

git diff - конкретно эта команда сравнивает содержимое рабочей директории и предбанника

git diff --cached - покажет изменения, которые проиндексированы, но еще не в репозитории 
			(т.е. сравнивает содержимое предбанникаи и репозитория)

git diff index.html - покажет изменения в конкретном файле

git diff --name-only master feature - покажет только пути различаемых файлов в этих
					каталогах

git diff @ - посмотреть, что мы сделали с момента последнего коммита

git diff -- master - передать путь к каталогу или файлу с названием master

git diff --no-index - работает изолированно от репо и сравнивает вообще два любых файла
			на диске

git diff --word-diff - показать отличие по словам (удобно при анализе текстовых файлов)

Создать файл .gitattributes и записать в нем строку *.html diff=html для того, чтобы 
правильно осуществлялась обработка содержимого по регулярным выражениям с учетом формата файла

git log --pretty=medium - это значение по умолчанию (соответствует git log)

git log --oneline - сокращенный вывод информации

git log pretty=format: '%h %cd | %s%d [%an]' - кастомизированный вывод информации:
%h - сокращенный идентификатор коммита, %cd - дата, %s - заголовок коммита, 
%d - декорирование (т.е. какие ссылки указывают на коммит) и [%an] - автор коммита

git hist - графическое отображение структуры репозитория

git log index.html - покажет коммиты, в которых изменялся файл index.html

git log --grep Run - выводит список коммитов, где есть слово Run в текущей ветке
		(но можно передать имя любой ветки)

git log --grep Run --grep sayHi - выводит список, где есть либо первое слово, либо второе

git log --grep sayhi -i - производит поиск без учета регистра 

git log --grep Run --grep sayHi --all-match - выводит список, где есть оба слова 

git log --grep 'say(Hi|Bye)' -P - включаются перлосовместимые РЕ (без флага не сработает)

Для активации перлосовместимых РЕ можно ввести команду настройки:
git config --global grep.patternType perl

git log -F - отключение РЕ (поисковая строка будет воприниматься как обычный текст ?!)

git log -G'sayHi' - выведет список коммитов, в коде файлов которых есть изменения 
строки 'sayHi' (флаг -p выведет фрагменты файлов с изменениями строки 'sayHi')

git log -G'function sayHi \(' - скобки, как спец. символы, надо экранировать

git log -L 3,6:index.html - выведет все коммиты, где есть изменения в файле index.html
		в диапазоне с 3 по 6 строки
git log -L '/head>/','/<\/head>/':index.html - то же, но поиск производится по РЕ

git log -L '/^function sayHi/','/^}/':index.html - ищем функцию sayHi

git log --author=<username> - поиск по автору коммита (или по коммитеру - флаг --commiter)

git log --before '2019-28-03' - поиск по дате (и по времени - 08:25:12), есть флаг --after

git blame index.html - посмотреть, кто именно написал каждую строку в файле


СЛИЯНИЕ

git merge-base master feature - покажет коммит, на котором ветки разделились

base - общий коммит (где ветка feature отошла от ветки master)

our - наш последний коммит (HEAD), мы на ветке master

their - последний коммит на ветке feature

Таким образом: base + (our changes) + (their changes) -> merge

cat .git/MERGE_HEAD - посмотреть id коммита из ветки feature, с которым будет
			произведено слияние 

<<<<< HEAD

версия кода из ветки master

========

версия кода из ветки feature

>>>>>>>

git checkout --ours index.html - возьмут вариант файла из нашей ветки (из HEAD)

git checkout --theirs index.html - возьмут вариант файла из ветки feature

git reset --hard - такой командой можно отменить слияние

git reset --merge - оставляет незакоммиченные изменения в файлах, которые 
			не участвовали в слиянии

git merge --abort - делает то же самое, что и команда выше

git checkout --conflict=diff3 --merge index.html - выводит информацию не только
о конфликтующих версиях файла, но и версии из последнего общего коммита 
(того, от которого и пошли эти ветки): в коде появится фрагмент, выделенный так:
||||||| base

Такое отображение конфликта (base - ours - theirs) можно задать в настройках:
git config --global merge.conflictStyle diff3()

Эти версии можно посмотреть так (base - 1, ours - 2, theirs - 3):
git show :1:index.html - посмотреть базовую версию файла index.html и т.д.

После разрешения конфликта файл надо добавить в предбанник:
git add index.html
Далее его надо закоммитить: git merge --continue (или же просто git commit)
Тут же откроется файл для записи комментария коммита

git log --oneline --all --graph - выведет схему веток в репозитории

git show --first-parent - посмотреть отличие текущего варианта файла от того,
				что было у первого родителя

git show -m - покажет отличие от всех родителей по отдельности

git HEAD^ - покажет отличия от первого родителя

git HEAD^2 - покажет отличия от второго родителя

git HEAD^^ - покажет отличия от первого родителя первого родителя

git merge feature --log=5 - при слиянии в комментарии будут добавлены
описания 5 предыдущих коммитов с ветки feature (если написать просто --log,
то будут добавлены все описания, но не более 20)

git log master --oneline --first-parent - список коммитов только по 
первому родителю (т.е. по ветке master)

git commit --no-edit - коммит без написания комментария

git megre --no-ff - вместо перемотки делать делать коммит слияния

git config merge.ff false - отключить функцию перемотки

git merge --ff feature - явно включить функцию перемотки в ветке feature

git merge --squash fix - берет изменения из ветки fix и применяет их 
к текущему состоянию проекта, т.е. к рабочей директории и предбаннику
Далее делаем коммит - в итоге изменения упакованы в самый обычный коммит,
без всякой связи с веткой, из которой они были взяты


КОПИРОВАНИЕ КОММИТОВ

git cherry-pick D - находясь на ветке master, копируем с ветки feature коммит D,
создавая эквивалентный коммит D'
Принципиальное отличие cherry-pick от слияния - слияние копирует ветки целиком,
а cherry-pick скопирует только указанный коммит

git cherry-pick master...feature - копировать все коммиты из feature, которых нет 
					в master

В ходе копирования при возникновении конфликта можно ввести команды:

git cherry-pick -- abort - отменит уже скопированные коммиты и вернет все 
				в первоначальное состояние

git cherry-pick --continue - продолжит копирование (предварительно решив конфликт)

git cherry-pick --quit - остановиться там, где мы сейчас, и сбросить запомненное состояние
(какие коммиты уже были скопированы, а какие нет). 

git reset --hard @~ - отменить копирование одного коммита (или если n коммитов, то @~n)

git cherry-pick -n 54a4 - скопировать изменения из коммита 54а4 (с тем, чтобы их немного 
подредактировать), но без коммита (изменения будут в предбаннике, но не закоммичены)

git cherry master feature - сравнение веток master и feature на наличие эквивалентных коммитов
(например, возникших в результате копирования): выведет коммиты со знаками '-' - в ветке 
feature есть копия в master, а '+' - нет копии

git log --oneline feature...master - выводит симметрическую разность коммитов 
(флаг --cherry-mark помечает эквивалентные коммиты знаком '=',
а флаг --left-right - знаками '>' и '<' покажут, какой коммит из какой ветки,
в нашем случае '>' - это master, a '<' - feature)


RERERE

rerere = REuse REcorded REsolution (авторазрешение повторных конфликтов)

git config rerere.enabled true


ОБРАЩЕНИЕ КОММИТОВ

git revert @ - смотрит, какие изменения сделаны в указанном коммите (например, текущем)
		и создает коммит с противоположными изменениями

















