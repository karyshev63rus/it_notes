sudo - ставим перед каждой командой, если мы не зашли как суперюзер (не факт)

docker -v или docker --version - узнаем версию и сборку

docker run hello-world - качаем образ и создаем контейнер с приветствием

systemctl status docker - узнаем статус: активен и что там как))

docker info - общая информация: сколько  образов, контейнеров и т.д.

docker --help - помощь 
docker COMMAND --help - помощь для конкретной комманды COMMAND
docker <container, image, volume> - помощь, соответственно, для этих объектов

docker pull ubuntu - подтягиваем образ ubuntu из репозитория
docker run -i -t ubuntu bash - создает контейнер с ubuntu и взаимодействуем с 
ним в интерактивном режиме через bash

docker container ls - смотрим список запущенных контейнеров

docker run -it -d ubuntu bash - запуск контейнера в фоновом режиме (вход в 
контейнер выполнен не будет, т.е. строка приглашения к вводу # не появится)
узнаем номер или имя запущенного контейнера и входим в него командой
docker attach <имя или номер контейнера>
Ctrl+P и далее Ctrl+Q - выход из контейнера без его остановки (отдельной 
команды для этого нет, есть лишь сочетание клавиш)
после выхода строка выведет сообщение: read escape sequence
docker stop <имя или номер контейнера> - остановка контейнера
docker container prune - удаление всех остановленных контейнеров 
(ключ -f отключает вопрос "y/n")

docker run -it --name ubuntu_1 ubuntu bash - задаем имя командой --name
если добавить ключ --rm - контейнер удалится после его остановки.

монтирование папки (параметры: type, src, target и еще какой-то четвертый)
docker run -it --mount type=bind,src=/home/mick/Sandbox,
target=/from_host_to_docker/ --name hello_docker ubuntu bash
все параметры со значениями пишутся в одну строку, без пробелов

docker volume create my_volume - создает том (volume) с именем my_volume
docker volume ls - выводит список созданных томов (volume)
если docker-клиент и docker-демон находятся на одной машине, то в поле 
DRIVER будет написано local
монтирование тома (параметры те же)
docker run -it --mount type=volume,src=my_volume,target=/volume/ ubuntu bash
ls  volume/ - смотрим содержимое тома и выясняем, что он пуст
далее создаем в томе файл, выходим из контейнера и удаляем его, после этого 
создаем новый контейнер с подключением к тому my_volume (согласно 
параметрам, в контейнере это будет папка с именем volume) и выясняем, 
что файл в нем сохранился
информация о томах хранится в недрах docker-демона и путь до них чаще всего 
неизвестен
docker volume rm my_volume - удаление тома my_volume, но если том подключен, 
эта команды вызовет ошибку, т.к. удалить можно только отключенные тома
поэтому сначала нужно удалить контейнер, к которому примонтирован том (после 
чего вводим команду, указанную выше)
docker volume prune - команда удалит все отмонтированные контейнеры

эта команда создает контейнер с python и запускает скрипт из хостовой папки; 
опция readonly означает "только чтение" (чтобы программа не была изменена), 
а перед названием скрипта указывается имя папки, создаваемой в docker (в этом 
примере она называется bind)
docker run --rm --mount type=bind,src=/home/mick/,target=/bind/,readonly 
python python /bind/script.py
в опции target не забывать указывать "/" - это путь!

запуск питоновского скрипта из тома здесь идет в два этапа: сначала создаем 
том и записываем в него скрипт, потом его запускаем (каждый раз контейнер 
отрабатывает и удаляется)
1) docker run -it --rm --mount type=volume,src=python_program,
target=/volume/ ubuntu bash
внутри volume можно создать файл так: echo "print('Hi there!')" > 
my_python_script.py
2) docker run -it --rm --mount type=volume,src=python_program,
target=/src/ python python /src/my_python_script.py
источник python_program, если его еще не существует, создается автоматически
тэги - это метки, которые ставятся через ":", например, python:3.5 - 
создаем контейнер с версией python 3.5

docker image ls - просмотр образов, хранящихся на хост-машине
docker image rm <имя или номер образа> - удаление образа с диска машины
создание образа на основе другого, базового образа включает этапы:
1. создание контейнера от основного образа
2. настройка нужного софта
3. выход из контейнера
4. создание образа на основе контейнера
ставим редактор nano находясь внутри контейнера после команды docker run 
-it ubuntu bash:

apt-get update
apt-get install apt-file
apt-file update
apt-get install nano

выходим из контейнера и на его основе создаем образ (предварительно 
посмотрев номер контейнера):
docker commit <номер контейнера> <имя нового, создаваемого образа>

кастомизация - подмена команд и директорий в контейнере, на основе которого 
можно будет создать кастомизированный образ
docker run -it -w /home ubuntu pwd - создаст контейнер, который откроется 
в папке home, и это будет выведено командой pwd
-w - задает путь к директории, в которой откроется контейнер

docker tag ubuntu_with_nano karyshev63rus/ubuntu_with_nano - создаем копию 
нашего образа при помощи команды tag (для заливки на репозиторий docker.hub.com)

связывание портов: -p <порт хост-машины>:<порт docker-контейнера>
например, docker -d -rm -p 4444:4444 selenium/standardalone-chrome:3.141.59

docker run -it ubuntu - для демонстрации создания сети между контейнерами 
создаем еще один контейнер - на ubuntu, куда ставим утилиту curl.
команды для установки curl (после создания контейнера мы  находимся в нем):
apt-get update
apt-get install apt-file -y (ключ -у вводится для того, чтобы не команда 
не спрашивала разрещения на установку)
apt-file update
apt-get install curl -y
проверяем факт установки командой curl --help
далее выходим из контейнера (exit) и узнаем его номер (docker ps -a)
и создаем образ контейнера: docker commit <номер контейнера> ubuntu_with_curl
создаем контейнер на основе этого образа и проверяем работу curl:
docker run -it --rm ubuntu_with_curl
делаем запрос на интернет-ресурс: curl http://example.com (получаем ответ - 
html-страницу)
запрос на localhost: curl localhost:4444 - ответ "Connection refused"
причина в отсутствии установленной сети между контейнерами, поэтому 
останавливаем контейнер
пересоздаем контейнер: docker -it --rm --network host ubuntu_with_curl bash
после этого снова отправляем запрос командой curl на localhost:4444 - успешно

Dockerfile - текстовый файл, на основе которого создается образ по заранее 
прописанному сценарию
Например, создание такого образа (запускает программу на python):

FROM python #определяет базовый образ, на основе которого создается новый образ

WORKDIR /app #определяет рабочую директорию (осуществляется переход в нее)

COPY counter.py . #копируется файл counter.py с хост-машины в текущую 
директорию контейнера (это, согласно предыдущей строке, app)

CMD python counter.py #описывает стартовую команду с аргументами, что надо 
выполнить, когда контейнер будет запущен

Сборка образа из Dockerfile: docker build -t python_counter .
-t - ключ для задания имени нового образа (здесь - python_counter)
. - указание директории, где искать файлы и директории для команды COPY

docker-compose - файл для запуска и управления сетом докер-контейнеров
пример такого файла: docker-compose.yml 
version: "3" 

            #docker-compose работает с сервисами. 1 сервис - 1 контейнер
services: 

            #сервис - контейнер, созданный на основе Dockerfile
    python:

            #ключевое слово 'build' позволяет задать путь к Dockerfile для 
            #cоздания образа, который позволит запустить сервис
        build: . 

            #указываем название образа, который получится в процессе билда
        image: python_counter_service

            #имя контейнера, который будет стартовать от образаа
        container_name: python_counter_container

            #команда, которую надо запустить после создания образа
        command: python counter.py
запуск docker-compose файла (сначала собирается сам образ (или сервис), 
потом от него запускается контейнер):
docker-compose up

docker-compose down --rmi all - удаление docker-compose файлов

exec -it <docker-container name> bash - войти в контейнер в командной строке (если он запущен не под bash, а, например, под python с django-проектом)


