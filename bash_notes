Здесь будет, по сути, продолжение той информации, что уже не умещается в файле linux_notes (не умещается в том смысле, что файл  разросся и искать в нем нужную инфу становится проблематично). Основу этого файла (по крайней мере, его начала) будет составлять конспект книги Игоря Шпигоря "Программирование на Bash с нуля".

find <base_dir for search> -name <file or calalog name> -type d - ищем каталог по имени (если ищем файл, то флаг будет -f) 
возможен и такой вариант: find <base_dir for search>  -type d -name <file or calalog name>

find . -type f -path */objects/* -exec echo {} \; - выводит все файлы из текущего каталога (рекурсивно), путях которых есть участок /objects/

find / -path */doc/* -name README > result_and_errors.txt 2>&1 - потоки stdout и stderr перенаправляются в указанный файл (вроде бы, на первый взгляд, должно быть что-то вроде 2>&1 > result_and_errors.txt - но это не так, верна первая конструкция: сначала поток вывода связывается с файлом, а потом поток ошибок перенаправляется в это файл)

find / -path */doc/* -name README > result.txt 2> errors.txt - для направления потока вывода и потока ошибок в разные файлы операторы перенаправления указываются друг за другом

эти команды можно использовать в одном конвейере
find . -type f | grep "bash" - здесь на вход в grep подаются имена файлов (будут выведены файлы, содержащие в названии подстроку 'bash')
find . -type f | xargs grep "bash" - а здесь не имена файлов, а их содержимое (будут выведены строки из файлов (с указанием пути к этим файлам), содержащих подстроку 'bash', например: './linux_notes:#! /bin/bash - обязательно первая строка выполняемого файла'). Для этого утилите grep на поток ввода передается не текст, а имена файлов через параметры командной строки

Утилиты конвертации файлов в текстовый формат
pdftotext - pdf-файл в текстовый формат
pdfgrep - ищет pdf-файл по его содержимому
antiword - конвертирует файл ms office в текстовый формат
catdoc - то же
xdoc2txt - конвертирует файлы pdf и ms office в текстовый формат

man <command name> - традиционный способ вызовы инфы о команде
<command name> --help - вызываем справку
info <command name> - то же

du /usr/share -a -h | tee result.txt - данные об использовании дискового пространства (du) будет (tee) как записано в файл, так и выведено на экран (есть флаг -d, который устанавливает уровень рекурсии и  равен n; например, обход по каталогу без входа в подкаталоги будет иметь значение 1: -d 1)

du /usr/share -a -h | grep "\.html" | sort -h -r - можно еще и сортировать (флаг -r - от z до a, а флаг -h - который во втором случае - что означает, не знаю)

в итоге может получиться такой вот крокодил:
du /usr/share -a -h | tee du.txt | grep "\.html" | tee grep.txt | sort -h -r > result.txt

применение "|" и ";" приведет к разным результатам (параметр "-" утилиты grep добавляет данные со стандартного потока ввода в конец команды)
ls /usr/share/doc/bash | grep "README" * -
ls /usr/share/doc/bash ; grep "README" * -
в первом случае будет прочитано содержимое одного из файлов, где есть такая подстрока, а во втором сначала будет выведен список файлов, а уже потом содержимое указанного файла


find . -name "*.txt" -exec cp -t /tmp/notes {} \; - предлагается использовать команду exec, так как ls может неправильно прочитать имена файлов (в этом выражении осуществляется копирование файлов с расширением .txt из текущего каталога в каталог /tmp/notes, который надо предварительно создать)

cp -R ~/docs ~/docs-backup && echo "OK" > result.log || echo "Error" > result.log - реализация ветвления с применением логических И (&&) и ИЛИ (||) на примере копирования директорий: если все удается, то в файл пишется строка OK, если нет - Error

A && B || C - общее представление механизма ветвления (выражение читается слева направо, т.е. операторы левоассоциативны)

