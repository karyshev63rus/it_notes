Здесь будет, по сути, продолжение той информации, что уже не умещается в файле linux_notes (не умещается в том смысле, что файл  разросся и искать в нем нужную инфу становится проблематично). Основу этого файла (по крайней мере, его начала) будет составлять конспект книги Игоря Шпигоря "Программирование на Bash с нуля".

find <base_dir for search> -name <file or calalog name> -type d - ищем каталог по имени (если ищем файл, то флаг будет -f) 
возможен и такой вариант: find <base_dir for search>  -type d -name <file or calalog name>

find . -type f -path */objects/* -exec echo {} \; - выводит все файлы из текущего каталога (рекурсивно), путях которых есть участок /objects/

find / -path */doc/* -name README > result_and_errors.txt 2>&1 - потоки stdout и stderr перенаправляются в указанный файл (вроде бы, на первый взгляд, должно быть что-то вроде 2>&1 > result_and_errors.txt - но это не так, верна первая конструкция: сначала поток вывода связывается с файлом, а потом поток ошибок перенаправляется в это файл)

find / -path */doc/* -name README > result.txt 2> errors.txt - для направления потока вывода и потока ошибок в разные файлы операторы перенаправления указываются друг за другом

эти команды можно использовать в одном конвейере
find . -type f | grep "bash" - здесь на вход в grep подаются имена файлов (будут выведены файлы, содержащие в названии подстроку 'bash')
find . -type f | xargs grep "bash" - а здесь не имена файлов, а их содержимое (будут выведены строки из файлов (с указанием пути к этим файлам), содержащих подстроку 'bash', например: './linux_notes:#! /bin/bash - обязательно первая строка выполняемого файла'). Для этого утилите grep на поток ввода передается не текст, а имена файлов через параметры командной строки

Утилиты конвертации файлов в текстовый формат
pdftotext - pdf-файл в текстовый формат
pdfgrep - ищет pdf-файл по его содержимому
antiword - конвертирует файл ms office в текстовый формат
catdoc - то же
xdoc2txt - конвертирует файлы pdf и ms office в текстовый формат

man <command name> - традиционный способ вызовы инфы о команде
<command name> --help - вызываем справку
info <command name> - то же

du /usr/share -a -h | tee result.txt - данные об использовании дискового пространства (du) будет (tee) как записано в файл, так и выведено на экран (есть флаг -d, который устанавливает уровень рекурсии и  равен n; например, обход по каталогу без входа в подкаталоги будет иметь значение 1: -d 1)

du /usr/share -a -h | grep "\.html" | sort -h -r - можно еще и сортировать (флаг -r - от z до a, а флаг -h - который во втором случае - что означает, не знаю)

в итоге может получиться такой вот крокодил:
du /usr/share -a -h | tee du.txt | grep "\.html" | tee grep.txt | sort -h -r > result.txt

применение "|" и ";" приведет к разным результатам (параметр "-" утилиты grep добавляет данные со стандартного потока ввода в конец команды)
ls /usr/share/doc/bash | grep "README" * -
ls /usr/share/doc/bash ; grep "README" * -
в первом случае будет прочитано содержимое одного из файлов, где есть такая подстрока, а во втором сначала будет выведен список файлов, а уже потом содержимое указанного файла


find . -name "*.txt" -exec cp -t /tmp/notes {} \; - предлагается использовать команду exec, так как ls может неправильно прочитать имена файлов (в этом выражении осуществляется копирование файлов с расширением .txt из текущего каталога в каталог /tmp/notes, который надо предварительно создать)

cp -R ~/docs ~/docs-backup && echo "OK" > result.log || echo "Error" > result.log - реализация ветвления с применением логических И (&&) и ИЛИ (||) на примере копирования директорий: если все удается, то в файл пишется строка OK, если нет - Error

A && B || C - общее представление механизма ветвления (выражение читается слева направо, т.е. операторы левоассоциативны)

В книге рассматривается пример создания скрипта: данные из одного каталога архивируются и копируются в другой каталог. В итоге был получен такой скрипт:
----
#!/bin/bash

bsdtar -cjf "$1".tar.bz2 "$@" &&
  echo "bsdtar - OK" > results.txt ||
  { echo "bsdtar - FAILS" > results.txt ; exit 1 ; }

mv -f "$1".tar.bz2 /d &&
  echo "cp - OK" >> results.txt ||
  ! echo "cp - FAILS" >> results.txt
----

каталог /usr/local/bin - размещенный здесь файл с bash-скриптом можно будет  запустить из любой точки файловой системы (по сути, скрипт приобретает статус утилиты - для большего подобия стоит убрать расширение .sh)

Утверждается, но на практике подтвердить не удалось:
$@ - интерпретирует аргументы командной строки как набор слов, т.е. переданная строка "раз два три" будет прочитана как "раз" "два" "три"
$* - то же, но будет прочитана как одно слово, т.е. "раз два три" на вход -> "раз два три" на выход

Тестировал на скрипте:

#!/usr/bin/bash
echo "$@"
for i in "$@"; do echo $i; done
for i in $@; do echo $i; done
echo ----------
echo "$*"
for i in "$*"; do echo $i; done
for i in $*; do echo $i; done
echo ----------
for i in one two three; do echo $i; done

stdout:

ne two three
one two three
one
two
three
----------
one two three
one two three
one
two
three
----------
one
two
three

Задание значения переменной по умолчанию при подстановке
--------------------------------------------------------
cp "${directory:-~}" - если значение не задано, копирование будет произведено в домашнмй каталог

${parameter:-word} - если переменная parameter не объявлена или имеет пустое значение, подставится слово word

${parameter:=word} - то же условие, но сначала будет присвоено значение по умолчанию, а потом переменная будет подставлена (т.е. в отличие от первого случая, переменная будет не просто замещена словом word, а само слово word будет записано в переменную parameter)

${parameter:?word} - то же условие, но значение по умолчанию будет выведено в стандартный поток ошибок, после чего исполнение скрипта будет завершено с кодом возврата, отличным от 0

${parameter:+word} - то же условие, но подстановки не будет

Чтобы запустить дочерний процесс, надо вызвать новый экземпляр интерпретатора в окне терминала:
bash -c "<command, object and options>" - флаг -c означает, что команда будет передана на исполнение дочернему процессу Bash, например: filename="README.md"; bash c- 'echo "$filename"' (причем используются именно одинарные кавычки, отключающие все подстановки для строки в них - т.е. эта команда на экран ничего не выведет; если же кавычки будут двойными, будет выведено README.md)

Переменные оболочки - локальные переменные и переменные окружения, доступные для данного экземпляра интерпретатора (список этих переменных можно вызвать утилитой set без параметров, в vim это составляет более 5000 строк!)

Специальные параметры (у $* и $@ параметры начинаются не с нулевого - $0, a c первого - $1)
---------------------
$* - содержит все позиционные аргументы, переданные в скрипт. Без двойных кавычек каждый позиционный параметр подставляется как отдельное слово; с двойными - Bash подставляет одно слово, содержащее все параметры.
$@ - массив со всем позиционными параметрами, переданными в скрипт. без двойных кавычек Bash обрабатывает каждый элемент массива как строку без кавычек (исполняется word spliting). С двойными кавычками - обрабатывает каждый элемент массива как строку с кавычками (word spliting не происходит). 
$# - число позиционных параметров, переданных в скрипт
$1, $2, ... - содержит значение соответствующего позиционного параметра: $1 соответствует первому параметру, $2 - второму и т.д. Номера указываются в десятичной системе
$? - код возврата последней выполненной команды в активном режиме (fg). Если команды выполнялись в конвейере, параметр хранит код возврата последней из них
$- - содержит опции текущего экземпляра интерпретатора 
$$ - идентификатор процесса текущего экземпляра интерпретатора. При подстановке в subshell возвращает PID родительского процесса
$! - идентификатор процесса PID последней команды, запущенной в фоновом режиме
$0 - имя текущего командного интерпретатора или выполняемого в данный момент скрипта

export BROWSER_PATH='/opt/firefox/bin' - объявление переменной окружения

переменную можно сначала объявить, а потом поместить в глобальную  область видимости:
BROWSER_PATH='/opt/firefox/bin'
export BROWSER_PATH

env или export без параметров - просмотр объявленных переменных окружения
set без параметров - просмотр переменных оболочки 

declare -i number=42 - объявление переменной

declare -p PATH - флаг -p добавит в вывод атрибуты переменной

declate -f - флаг -f вызовет вывод информации только о функциях (можно после флага указать имя конкретной функции) 

команда declare также устанавливает атрибуты при объявлении новой переменной:
declare -i sum=11+2
text=11+2
в первом случае результатом будет число 13, во втором - строка '11+2'

Опции команды declare и соответствующие атрибуты переменных
---------------------
-a - объявленнная переменная является индексируемым массивом. Элементы этого массива доступны по целочисленным номерам
-A - то же, но ассоциативным массивом. Каждому элементу такого массива соответствует ключ-строка
-g - объявление переменной в глобальной области видимости скрипта. При этом переменная не попадает в окружение
-i - объявление целочисленной переменной. Присваиваемое ей значение обрабатывается как арифметическое выражение
-r - объявление константы. После объявления ей нельзя присвоить другое значение
-x - объявление переменной окружения
unset <имя переменной> - удаление переменной любого типа, кроме константы

Создание массива - из-за нуль-терминатора (символа, означающего в POSIX конец файла, а в Bash - конец строки) нет надежного способа разделить строку на подстроки нужным нам способом. Поэтому наряду со скалярными переменными в Bash были введены массивы. 

Создание индексируемого массива:
files=$(ls Documents/*.txt) - неправильно
declare -a $(Documents/*.txt) - правильно
однако Bash зачастую сам способен определить тип переменной, поэтому использование declare необязательно

echo "${files[@]}" - будут выведены все элементы массива
echo "${!files[@]}" - тоже, но уже индексы элементов массива
echo "{$filrs[@]:1:2}" - получение среза массива из двух элементов - с  индексами 1 и 2
readarray -t names_array < names.txt - создание массива из файла командой readarray

cp "${files[0]}" ~/Documents - копируем первый элемент из массива files в каталог Documents
cp "${files[@]}" ~/Documents - то же, но копируем все элементы
echo "${#files[@]}" - получение размера массива через символ #
unset 'files[3]' - удаление элемента массива с индексом 3
unset files - удаление всего массива

Создание ассоциативного массива (создается только таким образом):
declare -A contacts=(["Alice"]="alice@gmail.com" ["Bob"]="(697) 955-5984" ["Eve"]="(245) 317-0117"\ ["Mallory"]="mallory@hotmail.com")

Элементы массива можно задать по отдельности:
declare -A contacts
contacts["Alice"]="alice@gmail.com"
contacts["Bob"]="(697) 955-5984"
contacts["Eve"]="(245) 317-0117"
contacts["Mallory"]="mallory@hotmail.com"

Получение значений по ключам ассоциативного массива:
echo "${contacts["Bob"]}"
(697) 955-5984
echo "${contacts[@]}"
(697) 955-5984 mallory@hotmail.com alice@gmail.com (245) 317-0117

Получение списка всех ключей:
echo "${!contacts[@]}"
Bob Mallory Alice Eve

Получение размера массива:
echo "${#contacts[@]}"
4

Если поместить такой массив в скрипт, то по ключу - имени человека - можно получать соответствующие значения
----
#!/bin/bash

declare -A contacts=(
["Alice"]="alice@gmail.com"
["Bob"]="(697) 955-5984"
["Eve"]="(245) 317-0117"
["Mallory"]="mallory@hotmail.com")

echo "${contacts["$1"]}"
----

unset contacts - удаление всего массива
unset 'contacts[Bob]' - удаление элемента массива

