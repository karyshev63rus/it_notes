Основа конспекта - книжка Willam S. Vincent 
       "Django for professionals".
-------------------------------------------
Здесь будут указаны основные этапы построения django-проекта bookstore от создания виртуальной среды и до деплоя на Heroku.


ГЛАВЫ: 1. Docker, 2. Postgresql, 3. Bookstore Project
----------------------------------------------------
pip install pipenv

mkdir bookstore &&  cd bookstore

pipenv install django==3.1 

pipenv shell 

django-admin startproject bookstore .

./manage.py migrate

./manage.py runserver


touch Dockerfile

///////////////////////////////////////////////////////
# Pull base image

FROM python:3.8


# Set environment varialbes

ENV PYTHONDONOTWRITEBYTECODE 1

ENV PYTHONUNBUFFERED 1


# Set a directory

WORKDIR /code


# Install dependencies

COPY Pipfile Pipfile.lock /code/

RUN pip install pipenv && pipenv install --system

	
# Copy project

COPY . /code/
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

docker build . 
docker build -t <imagename> .


pipenv install psycopg2-binary

touch docker-compose.yml

////////////////////////////////////////////////////////////////
	version: '3.8'

services:
	
  web:
    build: .
    command: python /code/manage.py runserver 0.0.0.0:8000
    volumes:
      - .:/code
    ports:
      - 8000:8000
    depends_on:
      - db

  db:
    image: postgres:12	
    volumes:
      - postrges_data:/var/lib/postgresql/data/
    environment:
      - "POSTGRES_HOST_AUTH_METHOD=trust"

  volumes:
    postgres_data:
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

docker-compose up # --build
docker-compose up -d # --build
docker-compose up -f <docker-compose filename> - d # --build
docker-compose logs
docker-compose exec # web python manage.py makemigrations
docker-compose exec # web pipenv install psycopg2-binary
docker-compose down

Создаем кастомную модель пользователя
-------------------------------------
Обязательное условие создания - ОТСУТСТВИЕ ЛЮБЫХ МИГРАЦИЙ С НАЧАЛА ПРОЕКТА!
0. создали проект, можно запустить сервер и указать конфиги postgres

1. docker-compose exec web python manage.py [далее - $ DCPM] startapp users

2. #  users/models.py
...
from django.contrib.auth.models import AbstractUser

class CustomUser(AbstractUser):
    pass

3. # settings.py
INSTALLED_APPS = [
...
'users.apps.UsersConfig',
...
]

AUTH_USER_MODEL = 'users.Customuser'

и только теперь производим миграцию
$ DCPM makemigrations users
$ DCPM migrate

4. # users/forms.py
from django.contrib.auth import get_user_model
from django.contrib.auth.forms import UserCreationForm, UserChangeForm

class CustomUserCreationForm(UserCreationForm):
    class Meta:
        model = get_user_model()
        fields = ('email', 'username',)

class CustomUserChangeForm(UserChangeForm):
    class Meta:
        model = get_user_model()
        fields = ('email', 'username')

5. # users/admin.py
...
from django.contrib.auth import get_user_model
from django.contrib.auth.admin import UserAdmin

from .forms import CustomUserCreationForm, CustomUserChangeForm 

CustomUser = get_user_model()

class CustomUserAdmin(UserAdmin):
    add_form = CustomUserCreationForm
    form = CustomUserChangeForm
    model = CustomUser
    list_display = ['email', 'username']

admin.site.register(CustomUser, CustomUserAdmin)

6. $ DCPM crearesuperuser
7. заходим на http://127.0.0.1:8000/admin и видим "кастомную" панель админа


ГЛАВЫ: 4. Pages App, 5. Registration, 6. Static Assets
------------------------------------------------------
Для хранения  шаблона заглавной страницы создаем папку templates в корне проекта и отражаем это в конфигах (все это в рамках приложения Pages App)

# settings.py
...
TEMPLATES = [
    {
        ...
        'DIRS': [os.path.join(BASE_DIR, 'templates')],
        ...
    }
]
...

# views.py
from django.views.generic import TemplateView

class HomePageView(TemplateView):
    template_name = 'home.html'

Система регистрации посетителей сайта (БАЗОВЫЙ вариант)
-------------------------------------------------------
Основываемся на предустановленном приложении django.contrib.auth; здесь есть множество маршрутов для операций по аутентификации пользователей, например (соответственно, путь и имя пути к соответствующему контроллеру):
accounts/login/ [name='login']
account/logout/ [name='logout']
...
account/reset/done/ [name='password_reset_complete']

Явно указываем пути
# urls.py
...
urlpatterns = [
    ...
    path('accounts/', include('django.contrib.auth.urls')),
    ...
]
...

Соответственно, разработчиками уже написано
# django/contrib/auth/urls.py
...
urlspatterns = [
    path('login/', views.LoginView.as_view(), name='login'),
    ...
    path('reset/done/', views.PasswordResetCompleteView.as_view(), name='password_reset_complete'),
]
...

В шаблоне заглавной страницы указываем релевантную (правильно?))) ссылку
# home.html
...
{% if user.is_authenticated %}
  Hi, {{ user.name }}!
 <a href="{% url 'logout'  %}">Log Out</a>
{% else %}
  <p>You are not logged in</p>
 <a href="{% url 'login'  %}">Log In</a>
{% endif %}
...

Шаблоны для аутентификации здесь надо создавать самостоятельно (получается,что уже есть готовые формы в предустановленном приложении, которые и используют данные шаблоны), например:
# templates/registration/login.html
...
<form method='post'>
  {% csrf_token %}
  {{ form.as_p }}
  <button type='submit'>Log in</button>
</form>
...

После операций  по аутентификации, пользователя надо перенаправить на какую-то страницу, например
#  settings.py
LOGIN_REDIRECT_URL = 'home'
LOGOUT_REDIRECT_URL = 'home'

СОБСТВЕННО регистрация пользователя реализуется самим разработчиком проекта (возвращаемся к приложению users):
1.# users/urls.py
...
from  .vies import SigupPageView

urlpatterns = [
    path('signup/', SignupPageView.as_view(), name='signup'),
]

2. # urls.py
...
   path('accounts/', include('users.urls')),
...

3. # users/views.py
from django.urls import reverse_lazy
from django.views import generic
from .forms import CustomUserCreationForm

class SignupPageView(generic.CreateView):
    form_class = CustomUserCreationForm
    success_url = reverse_lazy('login')
    template_name = 'signup.html'

4. # templates/signup.html
...
<form method='post'>
  {% csrf_token %}
  {{ form.as_p }}
  <button type='submit'>Sign Up</button>
</form>
...

5. # home.html
...
{% else %}
    ...
    <a href="{% url 'signup' %}">Sign Up</a>
    ...
...

Конфигурирование статических файлов (css, images, js):
# settings.py
STATIC_URL = '/static/' # присутствует изначально, остальное добавляется
STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static'),] # определяется папка, где будет храниться статические файлы
STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles') # определяется папка, где будут собираться  файлы в результате выполнения компнды collectstatic (что требуется при развертывании приложения) 
STATICFILES_FINDERS = [
    "django.contrib.staticfiles.finders.FileSystemFinder",
    "django.contrib.staticfiles.finders.AppDirectoriesFinder",
] # определяется порядок поиска статистических файлов в файловой системе

Добавление статических файлов в шаблон происходит через тэги
# templates/_base.html
{% load static %}
<html>
  <head>
  ...
  <link rel='stylesheet' href="{% static 'css/base.css' %}">
  </head>
  <body>
  ...
  <script src="{% static 'js/base.js' %}"></script>
  </body>
</html>

# templates/home.html
...
{% block content %}
    ...
    <img class="bookcover" src="{% static 'images/django_book.jpg' %}">
    ...
{% endblock %}
...

Сбор статических файлов (для деплоя) в общую папку  осуществляется так
DCPM collectstatic

Устанавливаем приложение django-crispy-forms (рассматривать Bootstrap здесь пока не буду)
# settings.py
INSTALLED_APPS = [
...
'crispy_forms',
]

CRISPY_TEMPLATE_PACK = 'bootstrap4'

Вносим изменения в шаблоны, где используются формы (signup.html, login.html)
{{ forms|crispy }} # как сказано в репо на github, эти crispy-фильтры "придают формам элегантность"

ГЛАВА 7. Продвинутая регистрация пользователя
---------------------------------------------
Здесь вместо дефолтного приложения используется стороннее приложение, и его надо поставить 
$ DCPM django-allauth (не забыть после этого пересобрать DC)

1. # settings.py
INSTALLED_APPS = [
    ...
    'django.contrib.sites',
    ...
    'allauth.account',
]
...

LOGIN_REDIRECT_URL = 'home'

ACCOUNT_LOGOUT_REDIRECT = 'home' # вместо  LOGOUT_REDIRECT_URL = 'home'

SITE_ID = 1

AUTHENTICATION_BACKENDS = (
    'django.contrib.auth.backends.ModelBackend', # это уже есть изначально
    'allauth.account.auth_backends.AuthenticationBackend',
)

EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'

2. $ DCPM migrate

3. # urls.py
    ...
    path('accounts/', include('allauth.urls')),
    ...
Это приложение использует другие имена маршрутов (например, вместо login берется account_login), поэтому ниже в шаблонах их придется поменять

4. # Работа с шаблонами в папке templates 
mkdir templates/account
mv  templates/registration/login.html templates/account/login.html
mv  templates/signup.html templates/account/signup.html

rm -r templates/registration # опционально, можно, вроде бы, и не удалять

Теперь переименовываем в шаблонах имена маршрутов
# _base.html
используем account_signup, account_login, account_logout


Доводим шаблоны, предоставляемые приложением allauth, до ума
# settings.py
...
ACCOUNT_SESSION_REMEMBER = True # на странице по маршруту с именем account_login избавляемся от чек-бокса "Remember Me" 

ACCOUNT_SIGNUP_PASSWORD_ENTER_TWICE = False # на странице по маршруту с именем account_singup избавляемся от необходимости вводить пароль дважды

ACCOUNT_USERNAME_REQUIRES = False # на странице по маршруту с именем account_signup избавляемся от необходимости указывать при регистрации свое имя

ACCOUNT_AUTHENTICATION_METHOD = 'email' # на странице по маршруту с именем account_signup указываем, что аутентификация производится именно по имени ящика электронной почты 

ACCOUNT_EMAIL_REQUIRED = True # поле электронной почты при регистрации обязательно
ACCOUNT_UNIQUE_EMAIL = True # определяем, что имена ящиков электронной почты должны быть уникальны,т.е. две и более записей с одинаковым именем ящика не допускается

Кроме того, создается шаблон для маршрута account_logout (примерно как в account_login)
# templates/logout.html
...
<form method='post' action='{% url "account_logout" %}'>
  {% csrf_token %}
  {{ form|crispy }}
  <button type='submit'>Log Out</button>
</form>
...

ГЛАВЫ: 8. Environment Variables, 9. Email
-----------------------------------------
Здесь предлагается указывать переменные окружения в файле docker-compose.yml: при этом говорится, что если в ключе встречается знак доллара, то он им же и экранируется, т.е. $ -> $$
version: '3.8'
  
  services:
    web:
      ...
      environment:
       - SECRET_KEY=p$$s$afsfas8#fasifs+a[))sda_sdaf=-dfg
...

В самом приложении значения переменных окружения предлагается загружать так
# settings.py
SECRET_KEY = os.environ.get('SECRET_KEY')
DEBUG = int(os.environ.get('DEBUG',default=0))

ПРИКРУЧИВАЕМ EMAIL
Опять же используем возможности приложения allauth - его формы сообщений, отправляемых по электронной почте для подтверждения email-адреса, указанного при регистрации на сайте (и далее кастомизируем эти формы)

mkdir templates/account/email
touch templates/account/email/email_confirmation_subject.txt 
touch templates/account/email/email_confirmation_message.txt

дефолтные варианты этих форм приводятся в книге

далее определяем адрес почты отправителя (просто будет указываться в письме)
# settings.py
DEFAULT_FROM_EMAIL = 'admin@email.com'

В письме приходит ссылка, и она должна куда-то вести, поэтому  мы создаем страницу на сайте, где можно подтвердить адрес электронной почты

touch templates/account/email_confirm.html

Переходим от отправления писем в консоль к отправлению писем на реальные адреса электронной почты. Для этого нужно воспользоваться услугами специальных сервисов - здесь рекомендуется SMTP - но он дружить не захотел.
# settigs.py
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'

ГЛАВА 10. Books App
-------------------
Здесь начинается постровение центрального приложения проекта - интернет-магазина книг (для чего содается приложение books)
$ DCPM startapp books

1. # books/models.py
...
class Book(models.Model):
    title = models.CharField(max_length=200)
    author = models.CharField(max_length=200)
    price = models.DecimalField(digits=6, decimal_places=2)

    def __str__(self):
        return self.title

$ DCPM makemigrations books
$ DCPM migrate

2. # books/admin.py
...
from .models import Book

class BookAdmin(admin.ModelAdmin):
    list_display = ('title', 'author', 'price',)

admin.site.register(Book, BookAdmin)

Заходим в админку и делаем несколько записей в таблицу книг

3. Прописываем маршруты 
# urls.py
...
path('books/', include('books.urls')),
...

# books/urls.py
from .views import BookListView, BookDetailView
...
path('', BookListView.as_view(), name='book_list'),
path('<int:pk>', BookDetailView.as_view(), name='book_detail'),
...

4. # books/views.py
from django.views.generic import ListView, DetailView
from .models import Book

class BookListView(ListView):
    model = Book
    context_object_name = 'book_list'
    template_name = 'books/book_list.html'

class BookDetailView(DetailView):
    model = Book
    context_object_name = 'book'
    template_name = 'books/book_detail.html' 

5. Строим шаблоны для страниц: 1) со списком книг и 2) для отдельной книги 
# templates/books/book_list.html
...
{% for book in book_list %}
  <a href="{% url 'book_list' %}">{{ book.title }}</a>
{% endfor %}

# template/book_detail.html
<a href="{% url 'book_detail' book.pk %}">{{ book.title }}</a>
<p>{{ book.author }}</p>
<p>{{ book.price }}</p>

6. В файле модели Book применяем функцию (т.е. метод класса), возвращающую абсолютный путь по его названию
# def get_absolute_url(self):
    return reverse('book_detail', args[str(self.id)])

далее, соответственно, вносим изменения в шаблон 
<a href="{{ book.get_absolute_url }}">{{ book.title }}</a>

7. Замена ID на UUID в качестве первичного ключа
#books/models.py
import uuid
...

class Book(models.Model):
    id = models.UUIDField(
        primary_key=True,
        default=uuid.uuid4,
        editable=False)

# books/urls.py
...
path('<uuid:pk>', BookDetailView.as_view(), name='book_detail'),
]

ГЛАВА 11. Reviews App.
----------------------
Здесь в рамках приложения Books для написания комментариев для отдельых книгсоздается модель Review. Эта модель является вторичной по отношению к моделиBook приложения Books (проблематика внешних ключей для создания связей one-to-one, one-to-many, many-to-many).  

1. # books/models.py
...
from django.contrib.auth import get_user_model
...

class Book(models.Model):
    ...

class Review(models.Model):
    book = models.ForeignKey(
        Book,
        on_delete=models.CASCADE,
        related_name='reviews',
    )
    review = models.CharField(max_length=255)
    author = models.ForeignKey(
        get_user_model(),
        on_delete=models.CASCADE,
    )

    def __str__(self):
        return self.review

$ DCPM makemigrations books
$ DCPM migrate

2. # books/admin.py
...
.from models import Book, Review

class Reviewline(admin.TabularInline):
    model = Review

class BookAdmin(admin.ModelAdmin):
    inlines = [
        ReviewInline,
    ]
    list_display = ('title', 'author', 'price')

admin.site.reqister(Book, BookAdmin)

После этого в админке на индивидуальных станицах книг появятся формы для оставления комментариев

3. # templates/book/book_detail.html
Дополняем указанный шаблон кодом для отображения комментариев
...
<h3>Reviews</h3>
<ul>
  {% for review in book.reviews.all %}
  <li>{{ review.review }} ({{ review.author }})</li>
  {% endfor %}
</ul>
...

ГЛАВА 12. File/Image Uploads
----------------------------
Устанавливаем пакет для работы с media-файлами 
docker-compose exec web pipenv install pillow

# settings.py
MEDIA_URL = '/media/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')

mkdir -p media/covers

#  urls.py
...
from django.conf.urls.static import static
...

urlpatterns = [
    ...
] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

# books/models.py
...
class Book(models.Model):
    ...
    cover = models.ImageField(upload_to='covers/', blank=True)

$ DCPM makemigratiosn book
$ DCPM migrate

Добавляем в шаблон проверку на наличие обложки и отображаем обложку
# templates/book/book_detail.html
...
{% block content%}
<div class='book-detail'>
 {% if book.cover %}
   <img class='bookcover' src='{{ book.cover.url }}' alt='{{ book.title }}'>
 {% endif %}
...

ГЛАВА  13. Permissions
----------------------
Добавляем разрешение на просмотр страницы со списком книг - если посетитель сайта не авторизован, он будет перенаправлен на страницу входа (account_login) для авторизации
# books/views.py
from django.contrib.auth.mixins import LoginRecuiredMixin
...
class BookListView(LoginRequiredMixin, ListView):
    ...
    login_url = 'account_login'

class BookDetailView(LoginRequiredMixin, DetailView):
    ...
    login_url = 'account_login'

Добавляем получение посетителем специальных прав - на чтение всех книг
#books/models.py
...
class Book(models.Model):
    ...

    class Meta:
        permissions = [
            ('special_status', 'read_all_books'),
        ]
    ...

Добавляем класс-миксин для расширения функционала классов-контоллеров в плане получения разрешений
# books/views.py
from django.contrib.auth.mixins import (
    LoginRequiredMixin,
    PermissionRequiredMixin
)
...
class BookDetailView(
   ...,
   PermissionReguiredMixin,
   ...):
   ...

ГЛАВА: 14. Orders with Stripe
-----------------------------
Создаем приложение orders для покупки книг и в его рамках подключаемся к платежной системе Stripe
$ DCPM startapp orders

# settings.py
'orders.apps.OrdersConfig'

# urls.py
path('orders/', include('orders.urls'))

# orders/urls.py
...
from .views import OrderPageView, charge
...
path('charge/', charge, name='charge'),
path('', OrderPageView.as_view(), name='orders')

# orders/views.py
import stripe
from django.conf import settings
from django.contrib.auth.models import Permission
from django.views.generic.base import TemplateView
from django.shortcuts import render

stripe.api_key = settings.STRIPE_TEST_SECRET_KEY

class OrdersPageView(TemplateView):
    template_name = 'orders/purchase.html'

    def get_context_data(self, ** kwargs):
        context = super().get_context_data(**kwargs)
        context['stripe_key'] = settings.STRIPE_TEST_PUBLISHABLE_KEY
        return context

def charge(request):
    permission = Permission.objects.get(codename='special_status')
    u = request.user
    u.user_permissions.add(permission)
    if request.method = 'POST':
        charge = stripe.Charge.create(
            amount=3900,
            currency='usd',
            description='Purchase all books',
            source=request.POST['stripetoken']
        )
        return render (request,  'orders/charge.html')

Ставим стороннее приложение stripe, регистрируемся на их сайте, получаем тестовые ключи, прописываем их названия в settings.py и значения в списке переменных среды в файле .env (как его читать, вопрос другой) 

# templates/orders/purchase.html
...
{% block content %}
<h1>Orders page</h1>
<p>Buy for $39.00</p>
<form action="{% url 'charge' %}" method="post">
{% csrf_token %}
<script src="https://checkout.stripe.com/checkout.js" class="stripe-button" 
    data-key="{{ stripe_key }}"
    data-description="All Books"
    data-amount="3900"
    data-locale="auto">
</script>
</form>
{% endblock content%}

# templates/charge.html
...
{% block content %} 
<h2>Thank you for your order! You now access to <a href="{% url 'book_list' %}">All Books</a>.</h2>
{% endblock content %} 

Далее в шаблоне book_list.html вносится условие "есть/нет доступа", которое, кстати, не работает (в коде автора на гитхабе это условие в поздних главах отсутствует)
# templates/books/book_list.html
...
{% if not perms.books.special_status %} 
<a href="{% url 'orders' %}" class="btn btn-success">Purchase All books</a>
{% endif %} 
...
...

ГЛАВА 15. Search
----------------
Вводим поиск
# books/urls.py
...
from .view import ... SearchResultsListView
...
path('search/', SearchResultListView.as_view(), name='search_results'),

# books/views.py
...
class SearchResultsListView(ListView):
    model = Book
    context_object_name = 'book_list'
    template_name = 'books/search_results.html'

    def get_queryset(self):
        query = self.request.GET.get('q')
        return Book.objects.filter(
            Q(title__icontains=query) | Q(author__icontains=query)
        )

Создаем шаблон результатов поиска - он выводит все книги, попавшие в фильтр
# templates/books/search_results.html
{% block content %} 
{% for %} 
<div>
<h3><a href="{{ book.get_absolute_url }}">{{ book.title }}</a></h3>
<p>Author: {{ book.author }}</p> 
<p>Price: {{ book.price }}</p> 
</div>
{% endfor %} 
{% endblock content %} 

Добавляем форму поиска на домашнюю страницу
# templates/home.html
...
<h1>Home page</h1>
<form action="{% url 'search_results' %}" method="get">
<input name="q" type="text" placeholder="Search" aria-label="Search">
</form>
...

ГЛАВА 16. Performance
---------------------
Устанавливаем отладочную панель debug-toolbar, для чего ставим приложение
$ DC exec web pipenv install django-debug-toolbar
и вносим дополнения в файл настроек

# settings.py
INSTALLED_APPS = [
...
    'debug_toolbar',
...
]

MIDDLEWARE = [
...
    'debug_toolbar.middleware.DebugToolbarMiddleware',
...
]

import socket

hostname, _, ips = socket.gethostbyname_ex(socket.gethostname())
INTERNAL_IPS = [ip[:-1] + "1" for ip in ips]

# urls.py
...
if settings.DEBUG:
    import debug_toolbar:
    urlpatterns = [
        path('__debug__/', include(debug_toolbar.urls)),
    ] + urlpatterns

настраиваем кэширование
# settings.py
...
MIDDLEWARE = [
    'django.middleware.cache.UpdateCacheMiddleware', 
    'django.middleware.cache.FetchFromCacheMiddleware', 
]

CACHE_MIDDLEWARE_ALIAS = 'default'
CACHE_MIDDLEWARE_SECONDS = 604800
CACHE_MIDDLEWARE_KEY_PREFIX = ''
...

вводим индексирование для повышения производительности БД
# books/models.py
...
class Book(models.Model):
    ...
    # db_index=True - указать индекс можно прямо в перечислении полей
    ...

    class Meta:
        indexes = [
            models.Index(fields=['id'], name='id_index'),
        ]
        ....

$ DCPM makemigrations books
$ DCPM migrate

ГЛАВА 17. Security
------------------
Проверка на готовность приложения к развертыванию в плане безопасности
$ DCPM check --deploy
Возможный ответ
System check  identified some issues:

WARNINGS:
...
System check identified 9 issues (0 silenced).

Начинаем их решать
# settings.py
ENVIRONMENT = os.environ.get('ENVIRONMENT', default='development')

Далее создаем два варианты docker-compose-файла: для разработки и эксплуатации (в одном из них - docker-compose-prod.yml прописываем ENVIRONMENT=production и также указываем DEBUG=0)

Составляем список разрешенных интернет-адресов для хостинга
ALLOWED_HOSTS = ['.herokkuapp.com', 'localhost', '127.0.0.1']
Не забывать добавлять префикс к heroku.com!!!

Решаем проблемы (заголовки в главе: Web Securityб SQL injenction, XXS (Cross Site Scripting), CSRF (Cross Site Request Forgery), Clickjacking Protection, HTTPS/SSL, HTTP Strict Transport Security (HSTS), Secure Cookies) путем добавления в settings.py следующих строк

if ENVIRONMENT == 'production':
    SECURE_BROWSER_XSS_FILTER = True
    X_FRAME_OPTIONS = 'DENY'
    SECURE_SSL_REDIRECT = True
    SECURE_HSTS_SECONDS = 3600
    SECURE_HSTS_INCLUDE_SUBMAINS = True
    SECURE_HSTS_RELOAD = True
    SECURE_CONTENT_TYPE_NOSNIFF = True
    SESSION_COOKIE_SECURE = True
    CSRF_COOKIE_SECURE = True

Предлагается обезопасить админку путем смены пути к ней
# urls.py
...
    path('anything-but_admin/', admin.site.urls),
...

ГЛАВА 18. Deployment
--------------------
Для развертывания на Heroku следует установить пакет для обслуживания файлов$ DC pipenv install whitenoise

# settings.py
INSTALLED_APPS = [
    ...
    'django.contrib.messages', # наш пакет указывается после него
    'whitenoise.runserver_nonstatic',
    'django.contrib.staticfiles', # наш пакет указывается перед ним
]

MIDDLEWARE = [
    'django.middleware.cache.UpdateCacheMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'whitenoise.middleware.WhiteNoiseMiddleware',
...
]

Собираем все статические файлы в одном месте
DCPM collectstatic

Ставим пакет для wsgi-перехода (от приложения к веб-серверу) 
$ DC pipenv install gunicorn

# docker-compose.yml и docker-compose-prod.yml
command: gumicorn <filename of our project>.wsgi -b 0.0.0.0:8000

Подготовка к работе с БД (сама база автоматически на сервер не переносится и будет создана вновь, поэтому не совсем понятно назначение этого пакета)
$ DC pipenv install dj-database-url

# settings.py 
...
import dj_database_url

df_from_env = df_database_url.config(conn_max_age=500)
DATABASE['default'].update(db_from_env)

HEROKU
------
Варианты установки на сайте самого Heroku не рассматривают случай с WSL. 
Но выход есть - команда curl https://cli-assets.heroku.com/install.sh | sh

В случае heroku добавляем в настройки
# settings.py
...
SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')
...

Далее создаем локальный репо и доводим его до коммита, после чего

1. $ heroku login

2. # heroku.yml
setup:
    addons:
    - plan: heroku-postgresql
build:
    docker:
        web: Dockerfile
release:
    image: web
    command:
    - python manage.py collectstatic --noinput
run:
    web: gunicorn bookstore_project.wsgi

3. heroku create # далее можно указать желаемое название <appname> будущего сайта на ресурсе .herokuapp.com (кстати, его можно сразу же записать в settings.py)
    
4. На сайте heroku вводим значения необходимых переменных окружения

5. Создаем или подтверждаем желание развертывать приложение в контейнере
$ heroku stack:set container -a <appname>

5. Прикручиваем БД
$ heroku addons:create heroku-postgresql:hobby-dev -a <appname>

6. Устанавливаем связь с удаленным репо на heroku и заливаем код
$ heroku git:remote -a <appname>
$ heroku git push heroku master

7. Выполням миграции для создания таблиц в новой БД и создаем суперюзера
$ DCPM migrate
$ DCPM createsuperuser

8. Открываем приложение в браузере
$ heroku open -a <appname>






Django. Полное руководство (Андрей Кудлай, компания "WebForMyself")
-------------------------------------------------------------------
Видеокурс из двух частей; краткий конспект некоторых уроков



ЧАСТЬ 1. ИЗУЧЕНИЕ DJANGO
------------------------


Урок 7. Модели.
---------------
# news/models.py
class News(models.Model):
    title = models.CharField(max_length=250)
    content = models.TextField(blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    photo = models.ImageField(upload_to='photos/%Y/%m/%d/')
    is_published = models.Boolean(default=True)


Урок 8. Миграции.
-----------------
Для работы с изображениями ставим приложение pillow: pip install pillow
python manage.py sqlmigrate <имя приложения> <номер миграционного файла>
Для настройки полей ImageField и FileField должны быть настроены две константы (они указывают фреймворку, куда загружать файлы; их значения указываются в settings.py): 
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')
MEDIA_URL = '/media/'
Чтобы загруженные файлы можно было просматривать на сайте, создается соответствующий маршрут, который будет указывать на загруженные файлы (для этого используется функция static из django.conf). Эта функция создаст маршрут, по которому маршрутизатор при запросе файлов передаст управление специальному контроллеру, который и отдаст файл для просмотра (этот маршрут необходим только в отладочном режиме):
# urls.py
Alt+Enter - вызов контекстного меню с опцией "import this name"
if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=MEDIA_ROOT)


Уроки 9 и 10. Основы работы с моделями. CRUD
--------------------------------------------
python manage.py shell
from news.models import News
News(title='News1', content='Content 1')
news1 = _
news1.save()
news1.title
news1.pk
from django.db import connection
connection.queries
news2 = News()
news2.title = 'News2'
news2.save()
news3 = News.objects.create(title='News3', content='Content 3')
News.objects.all()
News.objects.filter(title='News3')
News.objects.get(pk=3)
News.objects.order_by('-title')
News.objects.exclude(title='News2'))


Урок 11. Шаблоны
----------------
# news/views.py
return render(request, 'news/index.htnl', {'news': news, 'title': 'Список новостей'})
или
news = News.objects.order_by('-created_at')
contex = {
  'news': news,
  'title': 'Список новостей'
}
return render(request, template_name='news/index.html', context=context)
# index.html
<p>{{ item.created_at|date:"Y-m-d H:i" }}</p>


Урок 12. Админка Django
-----------------------
# news/admin.py
class NewsAdmin(admin.ModelAdmin):
    list_display = ('id', 'title', 'created_at', 'updated_at', 'is_published')
    list_display_links = ('id', 'title')
admin.site.register(News, NewsAdmin)
# news/models.py
...Field(..., verbose_name='Заголовок')
class Meta:
    verbose_name = 'Новость'
    verbose_name_plural = 'Новости'
    ordering = ['-created_at'] # теперь можно убрать эту строку из 
views.py
Не забываем сделать миграцию!
# apps.py
name = 'news'
verbose_name = 'Новости'


Урок 13. Связи моделей
----------------------
# models.py
Вводим новую модель Category:

class Category(models.Model):
    title = models.CharField(max_length=25, db_index=True, verbose_name='Наименование категории')

    def __str__(self):
        return self.title

    class Meta:
        verbose_name = 'Категория'
        verbore_name_plural = 'Категории'
        ordering = ['title']

Далее добавляем в модель News (теперь это вторичная модель) поле для связи с моделью Category (первичная модель):
category = models.ForeignKey('Category', on_delete=PROTECT, defautl=null)
При этом, если бы модель Category была бы объявлена ранее модели News, то вместо строки 'Category' надо было бы  указать ссылку Category:
category = models.ForeignKey(Category, on_delete=PROTECT, null=True)
При изменении модели News возникает вопрос, какими значениями дополнить это поле, ведь в таблице уже есть записи, сделанные до появления этого поля. Именно для этого указывается аргумент null=True. Попытка указания какого-либо дефолтного значения, например, default=1, приведет к проблемам с миграцией базы данных (в примере специально было произведено такое действие, вызвавшее исключение, и решением стало удаление файлов миграции, в которых отражалось создание новой, первичной таблицы и указания внешнего ключа во вторичной таблице; т.е. был произведен откат базы).
В поле title модели Category указываем db_index=True для индексации записей, что обеспечивает ускоренный поиск по БД (поле с первичным ключом имеет такой индекс по умолчанию). 

Вносим дополнения и изменения в настройку административной части:
# admin.py
...
class NewsAdmin(admin.ModelAdmin):
    ...
    list_editable = ('is_published', ) # список редактируемых полей (вместо цветовых индикаторов появляются чек-боксы)
    list_filter = ('is_published', 'category') # список полей для фильтрации (справа появляется боковая панель "Фильтр")

class CategoryAdmin(admin.ModelAdmin):
    list_display = ('id', 'title')
    list_display_links = ('id', 'title')
    search_fields = ('title',)
...
admin.site.register(Category, CategoryAdmin)


Урок 14. Внешний вид шаблона
----------------------------
Подключаем bootstrap (getbootstrap.com) через cdn-ссылку (обеспечивает подкачку версии фреймворка через сеть доставки контента). Для этого просто копируем код Starter template (правый сайдбар) и вставляем в нужный html-файл (например, index.hmtl).
Настраиваем бутстрап-шаблон под логику сайта: вносим в него директивы, тэги и фильтры. Интересен момент отображения данных, получаемых вторичной моделью от первичной модели через внешний ключ:
# index.html
...
{% for item in news %}
  <p>{{ item.category }}</p>
...
Здесь будет отображаться название категории, но только потому, что в первичной модели прописан метод __str__ (т.е. вторичная модель, из которой получены данные в news, получает данные по полю category от первичной модели, в которой определено это значение). Если бы этот метод не был бы определен, следовало бы обращаться с указанием поля первичной модели (item.category.title).


Уроки 15 и 16. Директивы, теги и фильтры (Часть 1 и Часть 2)
------------------------------------------------------------
В шаблонах можно обращаться не только к атрибутам, но и методам
# models.py
...
class News(models.Model):
...
    def my_func(self):
        return 'Hello from model'
...
# index.html
...
{% for item in news%}
  <p>{{ item.my_func }}</p>
...

Тэг {{% autoescape %}} контролирует авто-экранирование, т.к. по умолчанию html-тэги в шаблонах экранируются (в целях безопасности и  борьбы с инъекциями):
{% autoescape off %}
  <p class="content">{{ item.content }}</p>
{% endautoescape %}

{% comment %} Здесь закомментированный код {% endcomment %}

{% cycle %} - чередует расцветку строк при выводе данных в цикле
<h5 class="card-title" {% cycle 'text-danger' text-success' %}>...</h5>

{% for item in news reversed %} - выводит объекты в обратном порядке
  {{ forloop.counter }} - выводит номер текущей итерации цикла начиная с 1
  ...
  {% empty %} - выводит сообщение, если не находится искомых объектов
  <li>Sorry, no items in the list.</li>
{% endfor %}

{% if ... %}; {% elif ... %}; {% else %}; {% endif %} - тэги ветвления
{% if client_list and staff_list or total_list %} - код в Django
  ...
if (client_list and staff_list) or total_list: - обычный нативный код
    ...
{% lorem [count] [method] [random] %} - генерирует случайный текст

{% now "jS F Y H:i" %} - показывает текущее время в указанном формате

{% if item.photo %}
  <img src="{{ item.photo.url }}" alt="">
{% else %}
  ### lorem images ###

{{ value|date }} - фильтр (преобразователь) форматирования даты

{{ value|first }} - фильтр возвращает первый элемент списка

{{ value|floatformat:3 }} - возвращает число с тремя знакамм после запятой


Глава 17. Параметры в URL-запросах
----------------------------------
Формирование вывода статей по определенным категориям. Название 'category_id' фигурирует в БД, поэтому сначала указываем его в маршруте, а потом передаем в контроллер, где уже переменную с таким названием извлекаем из БД (т.е. в category_id=category_id слева стоит значение поля с таким названием в таблице news в БД, a справа - параметр, переданный в контроллер, для формирования результатов запроса по конкретной записи):
# urls.py
...
path('category/<int:category_id>', get_category),
...
# views.py 
...
def indext(request):
    news = News.objects.all()
    categories = Category.objects.all()
    context = {
        'news': news,
        'title': 'Список новостей',
        'categories': categories,
    }
    return render(request, template_name='news/index.html', context=context)

def get_category(request, category_id):
    news = News.objects.filter(category_id=category_id)
    categories = Category.objects.all()
    category = Category.get(pk=category_id)
    return render(request, 'news/category.html', {'news': news, 'categories': categories, 'category': category})

# index.html
...
<a href="/">HomePage</a>
...
{%  for item in categories %}
  <a href="/category/{{ item.pk }}">{{ item.title }}<a/>
{% endfor %}
...
{% for item in news %}
  Категория {{ item.category }}
  <p> {{ item.title }}</p>
  <p> {{ item.content }}</p>
...

# category.html
...
{{ category.title }} - указан в заголовке страницы
...
В этом файле код будет примерно таким же, как и в index.html, но выводиться данные будут только по определенной категории, потому что в контроллере формируется сокращенный объект запроса, ограниченный номером категории.


Глава 18. Имена маршрутов
-------------------------
Даем имена маршрутам:
# urls.py
...
path('', index, name='home'),
path('categories/<int:category_id>', get_category, name='category'),
...

# index.html
...
<a href="{% url 'home' %}">HomePage</a>
...
{% for item in categories %}
  <a href="{% url 'category' item.pk %}">{{ item.title }}</a>
...
{% for item in news %}
  <a href="{% url 'category' item.category.pk %}">{{ item.category }}</a>
...

# category.html
...
{% for item in categories %}
  <a href="{% url 'category' item.pk %}">{{ item.title }}</a>
...
{% for item in  news %}
  Категория: {{ item.title }}
...


Глава 19. Наследование шаблонов
-------------------------------
Структура файлов и папок для  хранения шаблонов на данный момент:
mysite
     |
      config -> ...
      news -> templates -> news -> [index.html, category.html]
      templates -> base.html 
               |         
                inc -> [_nav.html]

# base.html
{% include  'inc/_nav.html' %}
{% block sidebar %}SIDEBAR{% endblock %}
{% block  content %}CONTENT{% endblock %}

# _nav.html
<nav class=...
<a class='navbar-brand' href="{% url 'home' %}">Новостной сайт</a>
...
<ul class="navbar-nav mr-auto">
  <li class="nav-item"><a class="nav-link" href="{% url 'home' %}">Главная</a></li>
  <li class="nav-item"><a class="nav-link" href="{% url 'home' %}">Добавить новость</a></li>
</ul>
...
</nav>


Глава 20. Пользовательские теги шаблона
---------------------------------------
Существует два вида таких тегов: simple_tag inclusion_tag

Создаем в папке приложения каталог templatetags
Внутри этого каталога создаем __init__.py и news_tags.py

# news_tags.py
from django import template
from news.models import Category

register = template.Library()

@register.simple_tag(name=get_list_categories)
def get_categories():
    return Category.objects.all()

Теперь в шаблонах (index.html category.html) вырезаем общий код и выносим его в _sidebar.html
# _sidebar.html
{% load news_tags %} 
...
{% get_list_categories as categories %}
{% for item in categories %}
  <a href="{% url 'category' item.pk %}>{{ item.title }}</a>
{% endfor %}
...

Введение данного тега позволяет убрать из кода функций views.py строки 
categories = Category.objects.all() и 'categories': categories

Для inclusion_tag создаем файл по адресу news/templates/news/list_categories.html, куда перенесем цикл из файла _sidebar.html без строки с get_list_categories:
<div>
  {% for item in categories %}
    <a href="{% url 'category' item.pk %}>{{ item.title }}</a>
  {% endfor %}
</div>

Далее пишем тег в # news_tags.py
...
@register.inclusion_tag('news/list_categories.html')
def show_categories():
    categories = Category.objects.all()
    return {'categories': categories}

Добавляем код в # sidebar.html
...
<br>
{% show_categories %}
На странице index.html должен появиться еще один список категорий

Можно передать аргументы и вывести их значения в шаблонах:

# news_tags.py
...
def show_categories(arg1="Hello", arg2="world")
...
    return {'categories': categories, 'arg1': agr1, 'arg2': arg2}

# list_categories.html
...
{{ arg1}} {{ arg2 }}
...

# sidebar.html
...
{% show_categories arg2='User' %} - на странице появится "Hello User"


Глава 21. Обратное разрешение адресов
-------------------------------------
Использование функции get_absolute_url()
# models.py
...
Class News(models.Model):
...
    def get_absolute_url(self):
        return reverse('views_news', kwargs={'news_id': self.pk})
...
Class Category(models.Model):
...
   def get_absolute_url(self):
       return reverse('category', kwargs={'category_id': self.pk})

Далее меняем в шаблонах выражения типа {% url 'category' item.pk %} на {{ item.absolute_url }} и {% url 'news' item.category.pk %} на {{ item.category.get_absolute_url }} 

Создаем вывод индивидуальной страницы для отдельной новости 
# urls.py
...
path('/news/<int:news_id>/', view_news, name='views_news'),
...

def view_news(request, news_id):
    news_item = News.objects.get(pk=news_id)
    return render(request, 'news/view_news.html', {'news_item': news_item})

Соответственно, создается шаблон #view_news.html
...
{{ news_item.title }} :: {{ block.super }}
...
<a href="{{ news_item.category.get_absolute_url }}">{{ news_item.category }}</a>
...
<p>{{ item.content|safe|linebreaks }}
...

Использование функции get_object_or_404
# views.py
...
def view_news(self, news_id):
    new_item = get_object_or_404(News, pk=news_id)
...


Урок 22. Статические файлы
--------------------------
Отладочный сервер django умеет обрабатывать статические файлы, хранящиеся в различных папках, расположенных в разных частях проекта. Однако для рабочего сервера необходимо, чтобы вся статика сайта находилась в одном месте. Для этого в корне сайта создается (самим django) папка static, для чего вводятся несколько констант:
STATIC_URL = '/static/' - добавляет префмкс к адресу статического файла
STATIC_ROOT = os.path.join(BASE_DIR, 'static') - указывает путь к папке, в которой хранятся все статисчекие файлы; кроме того, здесь будут собираться все статические файлы при подготовке к развертываню проекта на сервере (для этого существует команда python manage.py collectstatic)
STATICFILES_DIRS = [
    os.path.join(BASE_DIR, 'mysite/static'),
] - перечисляются пути к дополнительным папкам со статическими файлами (в данном примере создали такую папку static в конфигурационной папке mysite)
В созданной по вышеуказанной команде папке static появится среди прочих папка admin, где будет собрана вся статика админки.
Для хранения статики используется тот же вариант, что и для хранения шаблонов. Т.е. путь формируется так: <appname>/static/<appname>/<filename>

Подключение статики в html-файлы осуществляется тегом 
# base.html
{% load static %}
...
<link rel="stylesheet" href="{% static 'bootstrap/css/bootstrap.min.css' %}"> - подключаем стили bootstrap.css из папка static, что лежит в папке приложения (так же подключаются все другие библиотеки, например, jquery)


Уроки 23, 24, 25. Работа с формами (Части 1, 2, 3)
--------------------------------------------------
Создаем формы для публикации статей на сайте
# urls.py
...
path('news/add-news/', add_news, name='add_news'),
...

1) Создаем формы, которые м.б. как основанными на моделях, так и нет
ВАРИАНТ формы, НЕ основанной на модели
# forms.py
A) Начальный вариант, не включающий параметры различных настроек
from django import forms
from .models import Category

class NewsForm(forms.Form):
    title = forms.CharField(max_length=150)
    content = forms.CharField()
    is_published = forms.BooleanField()
    category = forms.ModelChoiceField(queryset=Category.objects.all())

B) Продвинутый вариант с параметрами
...
class NewsForm(forms.Form):
    title = forms.CharField(max_length=150, label='Название', widget=forms.TextInput(attrs={'class': 'form-control'}))
    content = forms.CharField(label='Текст', required=False, widget=forms.Textarea(attrs={'class': 'form-control', 'rows': 5}))
    is_published = forms.BooleanField(label='Опубликовано?', initial=True)
    category = forms.ModelChoiceField(empty_label='Выберите категорию','Категория', queryset=Category.objects.all(), widget=forms.Select(attrs={'class': 'form-control'}))

ВАРИАНТ формы, ОСНОВАННОЙ на модели
# forms.py
from django import forms
from .models import News

class NewsForm(forms.ModelForm):
    class Meta:
        model = News
        # fields = '__all__' 
        # но лучше указать поля явно, перечислив их
        fields = ['title', 'content', 'is_published', 'category']
        widgets = {
            'title': forms.TextInput(attrs={'class': 'form-control'}),
            'content': forms.Textarea(attrs={'class': 'form-control', 'rows': 5}),
            'category': forms.Select(attrs={'class': 'form-control'}),
        }

2) Создаем функции-обработчики для обоих вариантов форм
ВАРИАНТ для обработки формы, НЕ основанной на модели
# views.py
...
def add_news(request):
    if request.method == 'POST':
        form = NewsForm(request.POST)
        if form.is_valid():
            news = News.objects.create(**form.cleaned_data)
            return redirect(news) # непонятная строка, возможно, редирект срабатывает из-за того, что в модели News есть метод get_absolute_url().
    else:
        form = NewsForm()
    return render(request, 'news/add_news.html', {'form': form})

ВАРИАНТ для обработки модели, ОСНОВАННОЙ на модели
Здесь вместо строки news = News.objects.create(**form.cleaned_data) используется строка news = form.save()

3) Формируем шаблон для отображения формы (используется bootstrap)
Здесь используются различные варианты кастомизации полей формы
Общая конструкция
# add_news.html
...
{% block content %}
...
<form action="{% url 'add_news' %}" method="post">
    {% csrf_token %}
ЗДЕСЬ РАСПОЛАГАЮТСЯ ВАРИАНТЫ
    <button type="submit" class="btn btn-primary btn-block">Добавить новость</button>
</form>
{% endblock %}

A) Базовый "автоматический" вариант, без ручной кастомизации
    {{ form.as_p }}

B) Наиболеее гибкий, "ручной" вариант, где отдельно кастомизируется каждое поле формы с учетом его особенностей (ниже приводится фрагмент для поля title)
    {{ form.non_field.errors }}
    <div class='form-group'>
        <label for="{{form.title.id_for_label }}">Название: </label>
        {{ form.title }}
        <div class="invalid-feedback">
            {{ form.title.errors }} 
        </div>
    </div>
... # И так ровно столько раз, сколько заполняемых полей в форме

C) Промежуточный "полуавтоматический" вариант, использующий цикл
{% for field in form %}
<div class='form-group'>
    {{ field.label_tag }}
    {{ field }}
    <div class='invalid-feedback'>
        {{ field.errors }}
    </div>
</div>


Урок 26. Кастомные валидаторы
-----------------------------

Пишем валидатор для поля title формы NewsForm, основанной на модели News (условие валидности значения: имя не должно начинаться с цифры)
# forms.py 
...
import re
from django.core.exceptions import ValidationError
...
class NewsForm(forms.ModelForm):
...
    def clean_title(self):
        title = self.cleaned_data('title')
        if re.match(r'\d', title):
            raise ValidationError('Название не должно начинаться с цифры')
        return title


Уроки 27 и 28. Класс ListView (Часть 1 и Часть 2)
-------------------------------------------------
Меняем название контроллеров в # urls.py
...
from .views import HomeViews, NewsByCategory
...
path('', HomeViews.as_view(), name='home'),
path('', NewsByCategory.as_view(), name='category'),
...

# views.py
...
from django.views.generic import ListView
...
class HomeNews(ListView):
    model = News
    template_name = 'home_news_list.html'
    context_object_name = 'news'
    extra_context = {'title': 'Главная'}

По умолчанию в нашем примере шаблон получит имя 'news/news_list.html' - название формируется из имени приложения, имени модели и имени родительского контроллера-класса (ListView), и django будет искать именно этот шаблон. Но его имя можно переопределить, указав в контроллере-классе значение переменной template_name
В самом шаблоне результат получения данных из модели будет обозначаться как object_list, но и это имя можно переопределить через задание значения переменной context_object_name в контроллере.
Можно добавить и другие имена атрибутов, использовав переменную extra_context (но использовать его рекомендуют для статичных данных, например, для присвоения значения переменной title). Для динамичных же данных предлагается использовать (переопределить) следующий метод:

    def get_context_data(self, *, object_list=None, **kwargs):
        context = super().get_context_data(**kwargs) 
# делаем это для того, чтобы не затереть данные, которые были до этого, 
# поэтому записываем эти данные в переменную context и дополняем своими:
    context['title'] = 'Главная страница'
    return context

Для вывода на странице только тех новостей, что имеют статус "опубликованных", переопредеятся следующий метод:
    def get_queryset(self):
        return News.objects.filter(is_published=True)

Делаем подобное с контроллером, обрабатывающим данные модели Category, и возвращающим статьи выбранной категории
# views.py
...
class NewsByCategory(ListView):
    model = News
    template_name = 'news/home_news_list.html' 
# используем тот же самый шаблон (следим за методом get_queryset)
    context_object_name = 'news'
# если список пуст, то показывать его нет смысла, для чего используем
    allow_empty = False # выведет 404, т.е. запрещаем показ пустых списков

    def get_context_data(self, *, object_list=None, **kwargs):
        ...
        context['title'] = Category.objects.get(pk=self.kwargs['category_id'])


    def get_queryset(self):
        return News.objects.filter(category_id=self.kwargs['category_id'], is_published=True)

Можно передавать данные через параметры класса-контроллера в .as_view():
# urls.py
...
path(..., NewsByCategory.as_view(extra_content={'title': title}), ...),
...


Уроки 29 и 30. Класс DetailView. Класс CreateView
-------------------------------------------------
# urls.py - для использования pk вместо news_id
...
# path('news/<int:news_id>/', ViewNews.as_view(), name='view_news'),
path('news/<int:pk>/', ViewNews.as_view(), name='view_news'),
# path('news/add_news/', add_news, name='add_news'),
path('news/add_news/', CreateNews.as_view(), name='add_news'),
...

# models.py - для использования pk вместо news_id
...
class News(models.Model):
   ...
    def get_absolute_url(self):
        return reverse('view_news', kwargs={'pk': self.pk})
...

# views.py
...
from django.views.generic import ..., DetailView
...
class ViewNewns(DetailView):
    model = News
    # pk_url_kwarg = 'news_id' - можно использовать и такой атрибут, но
    template_name = 'news/news_detail.html'

Файл # news_detail.html создаем на основе файла view_news.html

Добавляем контроллер-класс для создания новостей в файл # views.py
...
from django.views.generic import ..., CreateView
from django.urls import reverse_lazy
...
class CreateNews(CreateView): 
    form_class = NewsForm
    template_name = 'news/add_news.html'
    # по умолчанию редирект здесь происходит за счет модели News и ее метода get_absolute_urli: django смотрит, есть ли у модели, с которой работает данный контроллер, метод get_absolute_url, и если этот метод есть, django его вызывает для того, чтобы тот построил ссылку, на которую нужно сделать редирект. Но можем написать и так:
    success_url = reverse_lazy('home')


Уроки 32 - 39. Django ORM
-------------------------
python manage.py shell
from news.models import News, Category

У.32
----
News.objects.all() - получаем все записи из бд
News.objects.order_by('pk') - получаем записи, отсортированные по полю news_id (т.е. по первичному ключу, и даже не надо вспоминать его название).Если перед 'pk' поставить минус, то сортировка будет проведена в обратном порядке
News.objects.all().reverse() - также меняет порядок (и, по-видимому, здесь так же по первичному ключу)
News.objects.get(pk=1) - выбор записи по первичному ключу
News.objects.get(title='News 5') - выбор записи по полю title
news5 = _ - запишем в переменную news5 результаты последнего запроса
news5 - получаем тот же результат последнего запроса
news5.is_published - опубликована ли эта запись (вернет True или False)
news5.category - вернет категорию записи (получение связанных данных; благодаря методу __str__ модели Category получаем не номер объекта, т.е. категории, а ее название)
news5.category.pk - вернет номер категории для данной статьи (например, 4)
news5.category.title - название категории (здесь, в общем случае, идет рассмотрение обращения к первичной модели через вторичную модель)
cat4 = Category.objects.get(pk=4)
news_cat4 = cat4.news_set.all() - получение данных из вторичной модели через обратную связь (и вывод на печать)
for item in news_cat4:
   print(item.title, item.is_published)
Выражение _set можно переназвать (в таком случае обратиться через _set более не получится):
# models.py
...
class News(models.Model):
...
   category = models.ForeignKey(..., related_name='get_news')
...
cat4.get_news.all() - применяем новое название

У.33
----
Lookups (лукапы) - фильтры
Синтаксис фильтра полей: <имя поля>__<фильтр> (через двойное подчеркивание)
News.objects.filter(pk__gt=4) - новости со значением pk более 4
News.objects.filter(pk__gte=4) - новости со значением pk не менее 4
News.objects.filter(title__contains='news') - в заголовке есть подстрока 'news', если использовать icontains, регистр будет игнорироваться (играет роль, когда идет работа с кириллицей)
News.objects.filter(pk__in=[9, 10, 11]) - берутся записи, имеющие значения первичных ключей  9, 10 и 11
News.objects.filter(pk__in=[9, 10, 11], title__contains='news') - то же, но с еще одним условием - в названии должно быть слово 'news'
Следует заметить, что в предыдущем примере используется логическое 'и'.

У.34
----
Получение первой или последней записи (по pk) или наиболее ранней или поздней записи (по значению конкретного поля)
News.objects.first()
News.objects.last()
News.objects.earliest('updated_at')
News.objects.latest('updated_at')

Сортировка по первичному ключу дает тот же результат
News.objects.order_by('pk').first()
News.objects.order_by('-pk').first()

Фильтруем новости по категории и берем первую из полученного набора
cat1 = Category.objects.get(pk=1)
news = cat1.news_set.all()
news = cat1.news_set.filter(pk_gt=1).first()

То же, но фильтруем по ряду категорий
cats = Category.objects.filter(pk__in=[1, 3])
News.objects.filter(category__in=cats)

Проверка наличия записей по условию и их подсчет
cat1 = Category.objects.get(pk=1)
cat1.news_set.exists() - наличие записей по категории 1
cat1.news_set.count() - количество записей по категории 1
News.objects.count() - общее количество записей

Получение предыдущей и последующей записей
news = News.objects.get(pk=5)
news.get_previous_by_created_at()
news.get_next_by_created_all()

При этом возможно применение фильтров
news.get_next_by_created_at(pk__gt=10, title__contains=7)

У.35
----
Получение записей из вторичной модели по какому-то значению из первичной модели и наоборот

Получаем записи из вторичной модели не по ключу первичной модели, а по значению другого из ее полей, для чего применяем синтаксис  <имя поля внешнего ключа>__<имя поля первичной модели>
News.objects.filter(category__title='Политика')

Получаем данные из первичной модели на основе условий фильтрации вторичной модели
Category.objects.filter(news__title__contains='news')

Получаем уникальные значения из набора
Category.objects.filter(news__title__contains='news').distinct()

Класс Q
from django.db.models import Q
операторы: | & ~ (соответственно, логические 'или', 'и' и 'не')

В запросе (здесь используется логическое 'и', так как перечисляем  условия через запятую) получим пустой набор, так как такой записи нет 
News.objects.filter(pk__in=[5, 6], title__contains='2')

Используем в этом случае класс Q (применяем логическое 'или')
News.objects.filter(Q(pk__in=[5, 6]) | Q(title__contains='2'))

Изменим запрос, убрав одно из условий и добавив логическое 'не'
News.objects.filter(Q(pk__in=[5, 6]) & ~Q(pk__lt=4))

У.36
----
Делаем срезы по набору записей
News.objects.all()[:3]
News.objects.all()[10:]
News.objects.all()[3:5]

Импортируем агрегирующие функции
from django.db.models import Min, Max, Count, Sum, Avg, Variance 
или просто
from django.db.models import *

Добавляем в модель News поле (отображает число просмотров новости)
# models.py
...
class News(models.Model):
...
views = models.IntegerField(default=0)
...

Получение минимального и максимального значений поля views
News.objects.aggregate(Min('views'), Max('views'))
или с присвоением имен
News.objects.aggregate(min_views=Min('views'), max_views=Max('views'))

Получение производного показателя - разницы между max и min
News.obkects.aggregate(diff=Max('views')-Min('views'))

Суммирование и усреднение
News.objects.aggregate(Sum('views'))
News.objects.aggregate(Avg('views'))

Не путать count() и Count()

У.37
----
Осуществляем запросы с группированием данных (annotate())

Вычисляем количество статей по каждой из категорий
cats = Category.objects.annotate(Count('news'))
for item in cats:
    print(item.title, item.news__count)
или, если дадим имя функции
cats = Category.objects.annotate(cnt=Count('news'))
for item in cats:
    print(item.title, item.cnt)

По каждой категории выводим статьи с максимальным числом просмотров
cats = Category.objects.annotate(max_views=Max('news__views'))
for item in cats:
    print(item.title,  item.max_views)

По каждой категории вычисляем общее число просмотров статей
cats = Category.objects.annotate(sum_views=Sum('news__views'))
for item in  cats:
    print(item.title, item.sum__views)

Метод annotate() возвращает набор, который далее можно фильтровать
cats = Category.objects.annotate(cnt=Count('news')).filter(cnt__gt=0)
...

Выводим на странице только те категории, в которых есть статьти. Для этого меняем код пользовательского тега show_categories в файле #news_tags.py
...
from django.db.models import Count
...
categories = Category.objects.annotate(cnt=Count('news')).filter(cnt__gt=0))
...

Указываем число статей по категориям в шаблоне #list_categories.html
...
<a href='{{ item.get_absolute_url }}'>{{ item.title }}{{ item.cnt }}</a>
...

У.38
----
Получение значений по ключам из словаря, который создаем:
news1 = News.objects.values('title', 'views').get(pk=1)
Значения news1['title'] и news1['views'] будут, а, например, news1['id'] или news1['as_published'] - нет, так как таких ключей нет словаре

Проверим, сколько было выполнено запросов к бд
from django.db import reset_queries 
reset_queries() - очищает буфер ранее выполненных запросов

news = News.object.values('title', 'views', 'category_title')

from django.db import connection
connection.quries - выводит результаты ранее выполненных запросов
Оказывается, что был выполнен один запрос с INNER JOIN

Класс F
from django.db.models import F

Изменение значения поля отдельной записи в таблице в бд
news = News.objects.get(pk=1)
news.views = F('views') + 1
news.save()

Поиск записей к определенным значением в одном из полей
News.objects.filter(content__icontains=F('title'))

Обертки над функциями, выполняемыми СУБД
from django.db.models.functions import Length
Получим данные о длине заголовков каждой из статей
news = News.objects.annotate(length=Length('title')).all()
for item in news:
    print(item.title, item.length)

У.39
----
"Чистый" SQL

from news.models import *
News.objects.raw("SELECT * FROM news_news")
news = _
for item in news:
    print(item.title,  item.pk,  item.is_published)

Плохая практика формирования запросов (чревата sql-инъекциями):
News.objects.raw("SELECT * FROM news_news" WHERE title = 'News 5'")

Хорошая практика - это использование параметров
News.objects.raw("SELECT * FROM news_news" WHERE title = %s", ['News5'])


Урок 40. Debug tool bar
-----------------------
pip install django-debug-toolbar

# settings.py
...
INSTALLED_APPS = [
...
debug_toolbar,
...
]
...
MIDDLEWARE = [
...
'debug_toolbar.middleware.DebugToolbarMiddleware',
...
]
...
INTARNAL_IPS = ['127.0.0.1']
...

# urls.py
...
if settings.DEBUG:
    import debug_toolbar

    urlpatterns = [
                path('__debug__/', include(debug_toolbar.utils)),
    ] + urlpatterns
...
Поставленный отладчик показывает дублирование sql-запросов, для решения проблемы редактируем # views.py (здесь уже используются классы)
...
class  HomeView(ListView): - дополняем класс новым аттрибутом
...
    queryset = News.objects.select_related('category')
либо дополняем класс новым методом
    def get_queryset(self):
        return News.objects.filter(is_published=True).select_related('category')
Примерно такие же изменения вносятся в класс NewsByCategory
В итоге число запросов удается снизить с 15 до 4


Урок.41 Кастомизация админки
----------------------------
Изменение внешнего вида и функциональности админки
С помощью debug_toolbar находим html-шаблон 'admin/base_site.html', создаем его копию в папке по адресу mysyte/templates/admin, где django найдет его прежде всего.  

# base_site.html
{% extends 'admin/base.html' %}
{% load static %}
...
{% block extrastyle %}
    <link rel="stylesheat" href="{% static 'css/admin.css' %}">
{% endblock %}
...

Далее создаем файл admin.css, в котором прописываем нужные стили

Изменяем заголовки в админке, для чего вносим дополнения в файл # admin.py
...
admin.site.site_title = 'Управление новостями'
admin.site.site_header = 'Управление новостями'

Дополняем панель приложения Новости в админке миниатюрами изображений
# admin.py
...
Class NewsAdmin(admin.ModelAdmin):
    list_display = (..., 'get_photo')

    def get_photo(self, obj):
        if obj.photo:
            return mark_safe(f'<img src="{obj.photo.url}">')
        else:
            return '-'
Для переименования в админке столба get_photo пишем метод
    def get_photo.short_description = 'Миниатюра'

Чтобы фото в админке выводилось не только в списке новостей, но и в опции "Изменить новость" надо указать список выводимых полей в файле # admin.py
...
Class NewsAdmin(admin.ModelAdmin):
...
    fields = ('title', ..., 'get_photo')
И поскольку некоторые из этих полей нередактируемы, надо указать из явно
    readonly_fields = ('get_photo', 'views', 'created_at, 'updated_at')

Наконец, добавлем панель для сохранения/удаления новостей в верхней части админки, указывая в модели NewsAdmin атрибут 
    save_on_top = True


Урок 42. Миксины
----------------
Их задача - расширение функциональности других классов через наследование

В папке templatetags создаем файл # utils.py
class MyMixin(object):
    mixin_prop = '' - определим свойство, которое в дальнейшем будет переопределяться при наследовании миксима другими классами
    def get_prop(self):
        return self.mixin_prop.upper()

Далее наследуем от этого миксина классы в файле # views.py
...
from .utils import MyMixin
...
class HomeView(MyMixin, ListView):
...
    mixin_prop = 'hello world'
...
   def get_context_data...
      ...
      context['mixin_prop'] = self.get_prop()
      return context

class NewsByCategory(MyMixin, ListView):
...
      здесь делаем то же самое

В шаблоне home_news_lsit.html можно вывести эту переменную:
...
{{ mixin_prop }}
...

Для большего понимания добавим еще один метод в # utils.py
def get_upper(self, string):
    return string.upper()

Тогда во # views.py
...
class HomeNews(MyMixin, ListView):
...
   def get_context_data(self, ...):
   ...
       context['title'] = self.get_upper('Главная страница')
   ...
Однако этот метод применим здесь лишь к строке, а с набором данных он работать не будет. Для решения этой проблемы дописываем метод в # utils.py
...
def get_upper_self, string):
    if ininstance(string, str):
        return string.upper()
    else:
        return string.title.upper()

И теперь в контроллере NewsByCategory пропишем в методе get_context_data
context['title'] = Category.objects.get(pk=self.kwargs['category_id'])

Управляем доступом к ресурсам (допускаем к добавлению новостей только авторизованных пользователей)
Сначала убираем кнопку "Добавить новость" для незарегистрированных пользователей, для чего пишем в файле # _nav.html
...
{% if request.user.is_authenticated %}
  <a href="{% url 'add_news' %}">Добавить новость</a>
{% endif %}
...
Далее закрываем доступ незарегистрированным пользователям к самой возможности добавлять новости, для чего пишем в файле # views.py
...
from django.contrib.auth.mixins import LoginRequiredMixin
...
class CreateNews(LoginRequiredMixin, CreateView):
...
здесь добавляется миксин (уже прописан) и прописываются варианты редиректа
    login_url = '/admin/'
    или
    login_url = reverse_lazy('home')
    или же вообще выбрасываем исключение
    raise_exception = True


Уроки 43 и 44. Постраничная навигация (Часть 1 и Часть 2)
---------------------------------------------------------
Пагинация (сначала реализуем через функцию, потом через класс)
# views.py
...
from django.core.paginator import Paginator
...

ФУНКЦИЯ
пишем тестовую функцию, которую далее можно преобразовать в рабочую
def test(request):
    objects = ['john1', 'paul1', 'george1', ['ringo1', 'john2', 'paul2']
    paginator = Paginator(objects, 2)
    page_num = request.GET.get('page', 1) - берем из запроса номер страницы, которую запрашивает пользователь, в ином случае берем 1
    page_objects = paginator.get_page(page_num)
    return render(request, 'news/test.html', {'page_obj': page_objects})

Далее добавляем маршрут в # urls.py
...
path('test/', test, name='test'),
...

Далее создаем # test.html
...
{% for name in page_obj.object_list %}
  <p>name</p>
{% endfor %}
...

Сам шаблон разметки пагинатора (выводит перечисление страниц до и после текущей) добавляем в # base.html
...
<ul class="pagination">
  {% for p in page_obj.paginator.page_range %}
  <li class="page-item">
    <a class="page-link" href="?page={{ p }}">{{ p }}</a>
  </li>
  {% endfor %}
</ul>
...

КЛАСС
Вносим изменения в класс-контроллер в файле # views.py
...
class HomeNews(MyMixin, ListView):
...
    pagynate_by = 2  

Опционально (???) вносим изменение в файле # news_tags.py
...
from django.db.models import Count, F
...
@register.inclusion_tag('news/list_categories.html')
def show_categories(...):
...
    categories = Category.objects.annotate(cnt=Count('news', filter=F('news__is_published'))).filter(cnt_gt=0)

Далее доводим до ума пагинацию в шаблоне # base.html
...
{% block content %}CONTENT{% endblock %}
{% if page_obj.has_other_pages %}
  {%if  page_obj.has_previous %}
    <a href="" >Previous</a>
  {% endif %}
  {% for  p in page_obj.paginator.page_range %}
    {% if page_obj.number == p %} - если атрибут number объекта page_obj равен текущему номеру страницы, то отметка будет подсвечена (?)
    <a href="">{{ p }}</a>
    {% elif p > page_obj.number|add: -3 and p < page_obj.number|add:3 %}
    {{ p }}
    {% endif %}
  {% endfor %}
  {% if page_obj.has_next %}
    <a href="">Next</a>
  {% endif %}
{% endif %}











