Основа конспекта - книжка Willam S. Vincent 
       "Django for professionals".
-------------------------------------------
Здесь будут указаны основные этапы построения django-проекта bookstore от создания виртуальной среды и до деплоя на Heroku.


ГЛАВЫ: 1. Docker, 2. Postgresql, 3. Bookstore Project
----------------------------------------------------
pip install pipenv

mkdir bookstore &&  cd bookstore

pipenv install django==3.1 

pipenv shell 

django-admin startproject bookstore .

./manage.py migrate

./manage.py runserver


touch Dockerfile

///////////////////////////////////////////////////////
# Pull base image

FROM python:3.8


# Set environment varialbes

ENV PYTHONDONOTWRITEBYTECODE 1

ENV PYTHONUNBUFFERED 1


# Set a directory

WORKDIR /code


# Install dependencies

COPY Pipfile Pipfile.lock /code/

RUN pip install pipenv && pipenv install --system

	
# Copy project

COPY . /code/
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

docker build . 
docker build -t <imagename> .


pipenv install psycopg2-binary

touch docker-compose.yml

////////////////////////////////////////////////////////////////
	version: '3.8'

services:
	
  web:
    build: .
    command: python /code/manage.py runserver 0.0.0.0:8000
    volumes:
      - .:/code
    ports:
      - 8000:8000
    depends_on:
      - db

  db:
    image: postgres:12	
    volumes:
      - postrges_data:/var/lib/postgresql/data/
    environment:
      - "POSTGRES_HOST_AUTH_METHOD=trust"

  volumes:
    postgres_data:
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

docker-compose up # --build
docker-compose up -d # --build
docker-compose up -f <docker-compose filename> - d # --build
docker-compose logs
docker-compose exec # web python manage.py makemigrations
docker-compose exec # web pipenv install psycopg2-binary
docker-compose down

Создаем кастомную модель пользователя
-------------------------------------
Обязательное условие создания - ОТСУТСТВИЕ ЛЮБЫХ МИГРАЦИЙ С НАЧАЛА ПРОЕКТА!
0. создали проект, можно запустить сервер и указать конфиги postgres

1. docker-compose exec web python manage.py [далее - $ DCPM] startapp users

2. #  users/models.py
...
from django.contrib.auth.models import AbstractUser

class CustomUser(AbstractUser):
    pass

3. # settings.py
INSTALLED_APPS = [
...
'users.apps.UsersConfig',
...
]

AUTH_USER_MODEL = 'users.Customuser'

и только теперь производим миграцию
$ DCPM makemigrations users
$ DCPM migrate

4. # users/forms.py
from django.contrib.auth import get_user_model
from django.contrib.auth.forms import UserCreationForm, UserChangeForm

class CustomUserCreationForm(UserCreationForm):
    class Meta:
        model = get_user_model()
        fields = ('email', 'username',)

class CustomUserChangeForm(UserChangeForm):
    class Meta:
        model = get_user_model()
        fields = ('email', 'username')

5. # users/admin.py
...
from django.contrib.auth import get_user_model
from django.contrib.auth.admin import UserAdmin

from .forms import CustomUserCreationForm, CustomUserChangeForm 

CustomUser = get_user_model()

class CustomUserAdmin(UserAdmin):
    add_form = CustomUserCreationForm
    form = CustomUserChangeForm
    model = CustomUser
    list_display = ['email', 'username']

admin.site.register(CustomUser, CustomUserAdmin)

6. $ DCPM crearesuperuser
7. заходим на http://127.0.0.1:8000/admin и видим "кастомную" панель админа


ГЛАВЫ: 4. Pages App, 5. Registration, 6. Static Assets
------------------------------------------------------
Для хранения  шаблона заглавной страницы создаем папку templates в корне проекта и отражаем это в конфигах (все это в рамках приложения Pages App)

# settings.py
...
TEMPLATES = [
    {
        ...
        'DIRS': [os.path.join(BASE_DIR, 'templates')],
        ...
    }
]
...

# views.py
from django.views.generic import TemplateView

class HomePageView(TemplateView):
    template_name = 'home.html'

Система регистрации посетителей сайта (БАЗОВЫЙ вариант)
-------------------------------------------------------
Основываемся на предустановленном приложении django.contrib.auth; здесь есть множество маршрутов для операций по аутентификации пользователей, например (соответственно, путь и имя пути к соответствующему контроллеру):
accounts/login/ [name='login']
account/logout/ [name='logout']
...
account/reset/done/ [name='password_reset_complete']

Явно указываем пути
# urls.py
...
urlpatterns = [
    ...
    path('accounts/', include('django.contrib.auth.urls')),
    ...
]
...

Соответственно, разработчиками уже написано
# django/contrib/auth/urls.py
...
urlspatterns = [
    path('login/', views.LoginView.as_view(), name='login'),
    ...
    path('reset/done/', views.PasswordResetCompleteView.as_view(), name='password_reset_complete'),
]
...

В шаблоне заглавной страницы указываем релевантную (правильно?))) ссылку
# home.html
...
{% if user.is_authenticated %}
  Hi, {{ user.name }}!
 <a href="{% url 'logout'  %}">Log Out</a>
{% else %}
  <p>You are not logged in</p>
 <a href="{% url 'login'  %}">Log In</a>
{% endif %}
...

Шаблоны для аутентификации здесь надо создавать самостоятельно (получается,что уже есть готовые формы в предустановленном приложении, которые и используют данные шаблоны), например:
# templates/registration/login.html
...
<form method='post'>
  {% csrf_token %}
  {{ form.as_p }}
  <button type='submit'>Log in</button>
</form>
...

После операций  по аутентификации, пользователя надо перенаправить на какую-то страницу, например
#  settings.py
LOGIN_REDIRECT_URL = 'home'
LOGOUT_REDIRECT_URL = 'home'

СОБСТВЕННО регистрация пользователя реализуется самим разработчиком проекта (возвращаемся к приложению users):
1.# users/urls.py
...
from  .vies import SigupPageView

urlpatterns = [
    path('signup/', SignupPageView.as_view(), name='signup'),
]

2. # urls.py
...
   path('accounts/', include('users.urls')),
...

3. # users/views.py
from django.urls import reverse_lazy
from django.views import generic
from .forms import CustomUserCreationForm

class SignupPageView(generic.CreateView):
    form_class = CustomUserCreationForm
    success_url = reverse_lazy('login')
    template_name = 'signup.html'

4. # templates/signup.html
...
<form method='post'>
  {% csrf_token %}
  {{ form.as_p }}
  <button type='submit'>Sign Up</button>
</form>
...

5. # home.html
...
{% else %}
    ...
    <a href="{% url 'signup' %}">Sign Up</a>
    ...
...

Конфигурирование статических файлов (css, images, js):
# settings.py
STATIC_URL = '/static/' # присутствует изначально, остальное добавляется
STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static'),] # определяется папка, где будет храниться статические файлы
STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles') # определяется папка, где будут собираться  файлы в результате выполнения компнды collectstatic (что требуется при развертывании приложения) 
STATICFILES_FINDERS = [
    "django.contrib.staticfiles.finders.FileSystemFinder",
    "django.contrib.staticfiles.finders.AppDirectoriesFinder",
] # определяется порядок поиска статистических файлов в файловой системе

Добавление статических файлов в шаблон происходит через тэги
# templates/_base.html
{% load static %}
<html>
  <head>
  ...
  <link rel='stylesheet' href="{% static 'css/base.css' %}">
  </head>
  <body>
  ...
  <script src="{% static 'js/base.js' %}"></script>
  </body>
</html>

# templates/home.html
...
{% block content %}
    ...
    <img class="bookcover" src="{% static 'images/django_book.jpg' %}">
    ...
{% endblock %}
...

Сбор статических файлов (для деплоя) в общую папку  осуществляется так
DCPM collectstatic

Устанавливаем приложение django-crispy-forms (рассматривать Bootstrap здесь пока не буду)
# settings.py
INSTALLED_APPS = [
...
'crispy_forms',
]

CRISPY_TEMPLATE_PACK = 'bootstrap4'

Вносим изменения в шаблоны, где используются формы (signup.html, login.html)
{{ forms|crispy }} # как сказано в репо на github, эти crispy-фильтры "придают формам элегантность"

ГЛАВА 7. Продвинутая регистрация пользователя
---------------------------------------------
Здесь вместо дефолтного приложения используется стороннее приложение, и его надо поставить 
$ DCPM django-allauth (не забыть после этого пересобрать DC)

1. # settings.py
INSTALLED_APPS = [
    ...
    'django.contrib.sites',
    ...
    'allauth.account',
]
...

LOGIN_REDIRECT_URL = 'home'

ACCOUNT_LOGOUT_REDIRECT = 'home' # вместо  LOGOUT_REDIRECT_URL = 'home'

SITE_ID = 1

AUTHENTICATION_BACKENDS = (
    'django.contrib.auth.backends.ModelBackend', # это уже есть изначально
    'allauth.account.auth_backends.AuthenticationBackend',
)

EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'

2. $ DCPM migrate

3. # urls.py
    ...
    path('accounts/', include('allauth.urls')),
    ...
Это приложение использует другие имена маршрутов (например, вместо login берется account_login), поэтому ниже в шаблонах их придется поменять

4. # Работа с шаблонами в папке templates 
mkdir templates/account
mv  templates/registration/login.html templates/account/login.html
mv  templates/signup.html templates/account/signup.html

rm -r templates/registration # опционально, можно, вроде бы, и не удалять

Теперь переименовываем в шаблонах имена маршрутов
# _base.html
используем account_signup, account_login, account_logout


Доводим шаблоны, предоставляемые приложением allauth, до ума
# settings.py
...
ACCOUNT_SESSION_REMEMBER = True # на странице по маршруту с именем account_login избавляемся от чек-бокса "Remember Me" 

ACCOUNT_SIGNUP_PASSWORD_ENTER_TWICE = False # на странице по маршруту с именем account_singup избавляемся от необходимости вводить пароль дважды

ACCOUNT_USERNAME_REQUIRES = False # на странице по маршруту с именем account_signup избавляемся от необходимости указывать при регистрации свое имя

ACCOUNT_AUTHENTICATION_METHOD = 'email' # на странице по маршруту с именем account_signup указываем, что аутентификация производится именно по имени ящика электронной почты 

ACCOUNT_EMAIL_REQUIRED = True # поле электронной почты при регистрации обязательно
ACCOUNT_UNIQUE_EMAIL = True # определяем, что имена ящиков электронной почты должны быть уникальны,т.е. две и более записей с одинаковым именем ящика не допускается

Кроме того, создается шаблон для маршрута account_logout (примерно как в account_login)
# templates/logout.html
...
<form method='post' action='{% url "account_logout" %}'>
  {% csrf_token %}
  {{ form|crispy }}
  <button type='submit'>Log Out</button>
</form>
...

ГЛАВЫ: 8. Environment Variables, 9. Email
-----------------------------------------
Здесь предлагается указывать переменные окружения в файле docker-compose.yml: при этом говорится, что если в ключе встречается знак доллара, то он им же и экранируется, т.е. $ -> $$
version: '3.8'
  
  services:
    web:
      ...
      environment:
       - SECRET_KEY=p$$s$afsfas8#fasifs+a[))sda_sdaf=-dfg
...

В самом приложении значения переменных окружения предлагается загружать так
# settings.py
SECRET_KEY = os.environ.get('SECRET_KEY')
DEBUG = int(os.environ.get('DEBUG',default=0))

ПРИКРУЧИВАЕМ EMAIL
Опять же используем возможности приложения allauth - его формы сообщений, отправляемых по электронной почте для подтверждения email-адреса, указанного при регистрации на сайте (и далее кастомизируем эти формы)

mkdir templates/account/email
touch templates/account/email/email_confirmation_subject.txt 
touch templates/account/email/email_confirmation_message.txt

дефолтные варианты этих форм приводятся в книге

далее определяем адрес почты отправителя (просто будет указываться в письме)
# settings.py
DEFAULT_FROM_EMAIL = 'admin@email.com'

В письме приходит ссылка, и она должна куда-то вести, поэтому  мы создаем страницу на сайте, где можно подтвердить адрес электронной почты

touch templates/account/email_confirm.html

Переходим от отправления писем в консоль к отправлению писем на реальные адреса электронной почты. Для этого нужно воспользоваться услугами специальных сервисов - здесь рекомендуется SMTP - но он дружить не захотел.
# settigs.py
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'

ГЛАВА 10. Books App
-------------------
Здесь начинается постровение центрального приложения проекта - интернет-магазина книг (для чего содается приложение books)
$ DCPM startapp books

1. # books/models.py
...
class Book(models.Model):
    title = models.CharField(max_length=200)
    author = models.CharField(max_length=200)
    price = models.DecimalField(digits=6, decimal_places=2)

    def __str__(self):
        return self.title

$ DCPM makemigrations books
$ DCPM migrate

2. # books/admin.py
...
from .models import Book

class BookAdmin(admin.ModelAdmin):
    list_display = ('title', 'author', 'price',)

admin.site.register(Book, BookAdmin)

Заходим в админку и делаем несколько записей в таблицу книг

3. Прописываем маршруты 
# urls.py
...
path('books/', include('books.urls')),
...

# books/urls.py
from .views import BookListView, BookDetailView
...
path('', BookListView.as_view(), name='book_list'),
path('<int:pk>', BookDetailView.as_view(), name='book_detail'),
...

4. # books/views.py
from django.views.generic import ListView, DetailView
from .models import Book

class BookListView(ListView):
    model = Book
    context_object_name = 'book_list'
    template_name = 'books/book_list.html'

class BookDetailView(DetailView):
    model = Book
    context_object_name = 'book'
    template_name = 'books/book_detail.html' 

5. Строим шаблоны для страниц: 1) со списком книг и 2) для отдельной книги 
# templates/books/book_list.html
...
{% for book in book_list %}
  <a href="{% url 'book_list' %}">{{ book.title }}</a>
{% endfor %}

# template/book_detail.html
<a href="{% url 'book_detail' book.pk %}">{{ book.title }}</a>
<p>{{ book.author }}</p>
<p>{{ book.price }}</p>

6. В файле модели Book применяем функцию (т.е. метод класса), возвращающую абсолютный путь по его названию
# def get_absolute_url(self):
    return reverse('book_detail', args[str(self.id)])

далее, соответственно, вносим изменения в шаблон 
<a href="{{ book.get_absolute_url }}">{{ book.title }}</a>

7. Замена ID на UUID в качестве первичного ключа
#books/models.py
import uuid
...

class Book(models.Model):
    id = models.UUIDField(
        primary_key=True,
        default=uuid.uuid4,
        editable=False)

# books/urls.py
...
path('<uuid:pk>', BookDetailView.as_view(), name='book_detail'),
]

ГЛАВА 11. Reviews App.
----------------------
Здесь в рамках приложения Books для написания комментариев для отдельых книгсоздается модель Review. Эта модель является вторичной по отношению к моделиBook приложения Books (проблематика внешних ключей для создания связей one-to-one, one-to-many, many-to-many).  

1. # books/models.py
...
from django.contrib.auth import get_user_model
...

class Book(models.Model):
    ...

class Review(models.Model):
    book = models.ForeignKey(
        Book,
        on_delete=models.CASCADE,
        related_name='reviews',
    )
    review = models.CharField(max_length=255)
    author = models.ForeignKey(
        get_user_model(),
        on_delete=models.CASCADE,
    )

    def __str__(self):
        return self.review

$ DCPM makemigrations books
$ DCPM migrate

2. # books/admin.py
...
.from models import Book, Review

class Reviewline(admin.TabularInline):
    model = Review

class BookAdmin(admin.ModelAdmin):
    inlines = [
        ReviewInline,
    ]
    list_display = ('title', 'author', 'price')

admin.site.reqister(Book, BookAdmin)

После этого в админке на индивидуальных станицах книг появятся формы для оставления комментариев

3. # templates/book/book_detail.html
Дополняем указанный шаблон кодом для отображения комментариев
...
<h3>Reviews</h3>
<ul>
  {% for review in book.reviews.all %}
  <li>{{ review.review }} ({{ review.author }})</li>
  {% endfor %}
</ul>
...

ГЛАВА 12. File/Image Uploads
----------------------------
Устанавливаем пакет для работы с media-файлами 
docker-compose exec web pipenv install pillow

# settings.py
MEDIA_URL = '/media/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')

mkdir -p media/covers

#  urls.py
...
from django.conf.urls.static import static
...

urlpatterns = [
    ...
] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

# books/models.py
...
class Book(models.Model):
    ...
    cover = models.ImageField(upload_to='covers/', blank=True)

$ DCPM makemigratiosn book
$ DCPM migrate

Добавляем в шаблон проверку на наличие обложки и отображаем обложку
# templates/book/book_detail.html
...
{% block content%}
<div class='book-detail'>
 {% if book.cover %}
   <img class='bookcover' src='{{ book.cover.url }}' alt='{{ book.title }}'>
 {% endif %}
...

ГЛАВА  13. Permissions
----------------------
Добавляем разрешение на просмотр страницы со списком книг - если посетитель сайта не авторизован, он будет перенаправлен на страницу входа (account_login) для авторизации
# books/views.py
from django.contrib.auth.mixins import LoginRecuiredMixin
...
class BookListView(LoginRequiredMixin, ListView):
    ...
    login_url = 'account_login'

class BookDetailView(LoginRequiredMixin, DetailView):
    ...
    login_url = 'account_login'

Добавляем получение посетителем специальных прав - на чтение всех книг
#books/models.py
...
class Book(models.Model):
    ...

    class Meta:
        permissions = [
            ('special_status', 'read_all_books'),
        ]
    ...

Добавляем класс-миксин для расширения функционала классов-контоллеров в плане получения разрешений
# books/views.py
from django.contrib.auth.mixins import (
    LoginRequiredMixin,
    PermissionRequiredMixin
)
...
class BookDetailView(
   ...,
   PermissionReguiredMixin,
   ...):
   ...

ГЛАВА: 14. Orders with Stripe
-----------------------------
Создаем приложение orders для покупки книг и в его рамках подключаемся к платежной системе Stripe
$ DCPM startapp orders

# settings.py
'orders.apps.OrdersConfig'

# urls.py
path('orders/', include('orders.urls'))

# orders/urls.py
...
from .views import OrderPageView, charge
...
path('charge/', charge, name='charge'),
path('', OrderPageView.as_view(), name='orders')

# orders/views.py
import stripe
from django.conf import settings
from django.contrib.auth.models import Permission
from django.views.generic.base import TemplateView
from django.shortcuts import render

stripe.api_key = settings.STRIPE_TEST_SECRET_KEY

class OrdersPageView(TemplateView):
    template_name = 'orders/purchase.html'

    def get_context_data(self, ** kwargs):
        context = super().get_context_data(**kwargs)
        context['stripe_key'] = settings.STRIPE_TEST_PUBLISHABLE_KEY
        return context

def charge(request):
    permission = Permission.objects.get(codename='special_status')
    u = request.user
    u.user_permissions.add(permission)
    if request.method = 'POST':
        charge = stripe.Charge.create(
            amount=3900,
            currency='usd',
            description='Purchase all books',
            source=request.POST['stripetoken']
        )
        return render (request,  'orders/charge.html')

Ставим стороннее приложение stripe, регистрируемся на их сайте, получаем тестовые ключи, прописываем их названия в settings.py и значения в списке переменных среды в файле .env (как его читать, вопрос другой) 

# templates/orders/purchase.html
...
{% block content %}
<h1>Orders page</h1>
<p>Buy for $39.00</p>
<form action="{% url 'charge' %}" method="post">
{% csrf_token %}
<script src="https://checkout.stripe.com/checkout.js" class="stripe-button" 
    data-key="{{ stripe_key }}"
    data-description="All Books"
    data-amount="3900"
    data-locale="auto">
</script>
</form>
{% endblock content%}

# templates/charge.html
...
{% block content %} 
<h2>Thank you for your order! You now access to <a href="{% url 'book_list' %}">All Books</a>.</h2>
{% endblock content %} 

Далее в шаблоне book_list.html вносится условие "есть/нет доступа", которое, кстати, не работает (в коде автора на гитхабе это условие в поздних главах отсутствует)
# templates/books/book_list.html
...
{% if not perms.books.special_status %} 
<a href="{% url 'orders' %}" class="btn btn-success">Purchase All books</a>
{% endif %} 
...
...

ГЛАВА 15. Search
----------------
Вводим поиск
# books/urls.py
...
from .view import ... SearchResultsListView
...
path('search/', SearchResultListView.as_view(), name='search_results'),

# books/views.py
...
class SearchResultsListView(ListView):
    model = Book
    context_object_name = 'book_list'
    template_name = 'books/search_results.html'

    def get_queryset(self):
        query = self.request.GET.get('q')
        return Book.objects.filter(
            Q(title__icontains=query) | Q(author__icontains=query)
        )

Создаем шаблон результатов поиска - он выводит все книги, попавшие в фильтр
# templates/books/search_results.html
{% block content %} 
{% for %} 
<div>
<h3><a href="{{ book.get_absolute_url }}">{{ book.title }}</a></h3>
<p>Author: {{ book.author }}</p> 
<p>Price: {{ book.price }}</p> 
</div>
{% endfor %} 
{% endblock content %} 

Добавляем форму поиска на домашнюю страницу
# templates/home.html
...
<h1>Home page</h1>
<form action="{% url 'search_results' %}" method="get">
<input name="q" type="text" placeholder="Search" aria-label="Search">
</form>
...

ГЛАВА 16. Performance
---------------------
Устанавливаем отладочную панель debug-toolbar, для чего ставим приложение
$ DC exec web pipenv install django-debug-toolbar
и вносим дополнения в файл настроек

# settings.py
INSTALLED_APPS = [
...
    'debug_toolbar',
...
]

MIDDLEWARE = [
...
    'debug_toolbar.middleware.DebugToolbarMiddleware',
...
]

import socket

hostname, _, ips = socket.gethostbyname_ex(socket.gethostname())
INTERNAL_IPS = [ip[:-1] + "1" for ip in ips]

# urls.py
...
if settings.DEBUG:
    import debug_toolbar:
    urlpatterns = [
        path('__debug__/', include(debug_toolbar.urls)),
    ] + urlpatterns

настраиваем кэширование
# settings.py
...
MIDDLEWARE = [
    'django.middleware.cache.UpdateCacheMiddleware', 
    'django.middleware.cache.FetchFromCacheMiddleware', 
]

CACHE_MIDDLEWARE_ALIAS = 'default'
CACHE_MIDDLEWARE_SECONDS = 604800
CACHE_MIDDLEWARE_KEY_PREFIX = ''
...

вводим индексирование для повышения производительности БД
# books/models.py
...
class Book(models.Model):
    ...
    # db_index=True - указать индекс можно прямо в перечислении полей
    ...

    class Meta:
        indexes = [
            models.Index(fields=['id'], name='id_index'),
        ]
        ....

$ DCPM makemigrations books
$ DCPM migrate

ГЛАВА 17. Security
------------------
Проверка на готовность приложения к развертыванию в плане безопасности
$ DCPM check --deploy
Возможный ответ
System check  identified some issues:

WARNINGS:
...
System check identified 9 issues (0 silenced).

Начинаем их решать
# settings.py
ENVIRONMENT = os.environ.get('ENVIRONMENT', default='development')

Далее создаем два варианты docker-compose-файла: для разработки и эксплуатации (в одном из них - docker-compose-prod.yml прописываем ENVIRONMENT=production и также указываем DEBUG=0)

Составляем список разрешенных интернет-адресов для хостинга
ALLOWED_HOSTS = ['.herokkuapp.com', 'localhost', '127.0.0.1']
Не забывать добавлять префикс к heroku.com!!!

Решаем проблемы (заголовки в главе: Web Securityб SQL injenction, XXS (Cross Site Scripting), CSRF (Cross Site Request Forgery), Clickjacking Protection, HTTPS/SSL, HTTP Strict Transport Security (HSTS), Secure Cookies) путем добавления в settings.py следующих строк

if ENVIRONMENT == 'production':
    SECURE_BROWSER_XSS_FILTER = True
    X_FRAME_OPTIONS = 'DENY'
    SECURE_SSL_REDIRECT = True
    SECURE_HSTS_SECONDS = 3600
    SECURE_HSTS_INCLUDE_SUBMAINS = True
    SECURE_HSTS_RELOAD = True
    SECURE_CONTENT_TYPE_NOSNIFF = True
    SESSION_COOKIE_SECURE = True
    CSRF_COOKIE_SECURE = True

Предлагается обезопасить админку путем смены пути к ней
# urls.py
...
    path('anything-but_admin/', admin.site.urls),
...

ГЛАВА 18. Deployment
--------------------
Для развертывания на Heroku следует установить пакет для обслуживания файлов$ DC pipenv install whitenoise

# settings.py
INSTALLED_APPS = [
    ...
    'django.contrib.messages', # наш пакет указывается после него
    'whitenoise.runserver_nonstatic',
    'django.contrib.staticfiles', # наш пакет указывается перед ним
]

MIDDLEWARE = [
    'django.middleware.cache.UpdateCacheMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'whitenoise.middleware.WhiteNoiseMiddleware',
...
]

Собираем все статические файлы в одном месте
DCPM collectstatic

Ставим пакет для wsgi-перехода (от приложения к веб-серверу) 
$ DC pipenv install gunicorn

# docker-compose.yml и docker-compose-prod.yml
command: gumicorn <filename of our project>.wsgi -b 0.0.0.0:8000

Подготовка к работе с БД (сама база автоматически на сервер не переносится и будет создана вновь, поэтому не совсем понятно назначение этого пакета)
$ DC pipenv install dj-database-url

# settings.py 
...
import dj_database_url

df_from_env = df_database_url.config(conn_max_age=500)
DATABASE['default'].update(db_from_env)

HEROKU
------
Варианты установки на сайте самого Heroku не рассматривают случай с WSL. 
Но выход есть - команда curl https://cli-assets.heroku.com/install.sh | sh

В случае heroku добавляем в настройки
# settings.py
...
SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')
...

Далее создаем локальный репо и доводим его до коммита, после чего

1. $ heroku login

2. # heroku.yml
setup:
    addons:
    - plan: heroku-postgresql
build:
    docker:
        web: Dockerfile
release:
    image: web
    command:
    - python manage.py collectstatic --noinput
run:
    web: gunicorn bookstore_project.wsgi

3. heroku create # далее можно указать желаемое название <appname> будущего сайта на ресурсе .herokuapp.com (кстати, его можно сразу же записать в settings.py)
    
4. На сайте heroku вводим значения необходимых переменных окружения

5. Создаем или подтверждаем желание развертывать приложение в контейнере
$ heroku stack:set container -a <appname>

5. Прикручиваем БД
$ heroku addons:create heroku-postgresql:hobby-dev -a <appname>

6. Устанавливаем связь с удаленным репо на heroku и заливаем код
$ heroku git:remote -a <appname>
$ heroku git push heroku master

7. Выполням миграции для создания таблиц в новой БД и создаем суперюзера
$ DCPM migrate
$ DCPM createsuperuser

8. Открываем приложение в браузере
$ heroku open -a <appname>






Django. Полное руководство (Андрей Кудлай, компания "WebForMyself")
-------------------------------------------------------------------
Видеокурс из двух частей; краткий конспект некоторых уроков



ЧАСТЬ 1. ИЗУЧЕНИЕ DJANGO
------------------------


Урок 7. Модели.
---------------
# news/models.py
class News(models.Model):
    title = models.CharField(max_length=250)
    content = models.TextField(blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    photo = models.ImageField(upload_to='photos/%Y/%m/%d/')
    is_published = models.Boolean(default=True)


Урок 8. Миграции.
-----------------
Для работы с изображениями ставим приложение pillow: pip install pillow
python manage.py sqlmigrate <имя приложения> <номер миграционного файла>
Для настройки полей ImageField и FileField должны быть настроены две константы (они указывают фреймворку, куда загружать файлы; их значения указываются в settings.py): 
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')
MEDIA_URL = '/media/'
Чтобы загруженные файлы можно было просматривать на сайте, создается соответствующий маршрут, который будет указывать на загруженные файлы (для этого используется функция static из django.conf). Эта функция создаст маршрут, по которому маршрутизатор при запросе файлов передаст управление специальному контроллеру, который и отдаст файл для просмотра (этот маршрут необходим только в отладочном режиме):
# urls.py
Alt+Enter - вызов контекстного меню с опцией "import this name"
if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=MEDIA_ROOT)


Уроки 9 и 10. Основы работы с моделями. CRUD
--------------------------------------------
python manage.py shell
from news.models import News
News(title='News1', content='Content 1')
news1 = _
news1.save()
news1.title
news1.pk
from django.db import connection
connection.queries
news2 = News()
news2.title = 'News2'
news2.save()
news3 = News.objects.create(title='News3', content='Content 3')
News.objects.all()
News.objects.filter(title='News3')
News.objects.get(pk=3)
News.objects.order_by('-title')
News.objects.exclude(title='News2'))


Урок 11. Шаблоны
----------------
# news/views.py
return render(request, 'news/index.htnl', {'news': news, 'title': 'Список новостей'})
или
news = News.objects.order_by('-created_at')
contex = {
  'news': news,
  'title': 'Список новостей'
}
return render(request, template_name='news/index.html', context=context)
# index.html
<p>{{ item.created_at|date:"Y-m-d H:i" }}</p>


Урок 12. Админка Django
-----------------------
# news/admin.py
class NewsAdmin(admin.ModelAdmin):
    list_display = ('id', 'title', 'created_at', 'updated_at', 'is_published')
    list_display_links = ('id', 'title')
admin.site.register(News, NewsAdmin)
# news/models.py
...Field(..., verbose_name='Заголовок')
class Meta:
    verbose_name = 'Новость'
    verbose_name_plural = 'Новости'
    ordering = ['-created_at'] # теперь можно убрать эту строку из 
views.py
Не забываем сделать миграцию!
# apps.py
name = 'news'
verbose_name = 'Новости'


Урок 13. Связи моделей
----------------------
# models.py
Вводим новую модель Category:

class Category(models.Model):
    title = models.CharField(max_length=25, db_index=True, verbose_name='Наименование категории')

    def __str__(self):
        return self.title

    class Meta:
        verbose_name = 'Категория'
        verbore_name_plural = 'Категории'
        ordering = ['title']

Далее добавляем в модель News (теперь это вторичная модель) поле для связи с моделью Category (первичная модель):
category = models.ForeignKey('Category', on_delete=PROTECT, defautl=null)
При этом, если бы модель Category была бы объявлена ранее модели News, то вместо строки 'Category' надо было бы  указать ссылку Category:
category = models.ForeignKey(Category, on_delete=PROTECT, null=True)
При изменении модели News возникает вопрос, какими значениями дополнить это поле, ведь в таблице уже есть записи, сделанные до появления этого поля. Именно для этого указывается аргумент null=True. Попытка указания какого-либо дефолтного значения, например, default=1, приведет к проблемам с миграцией базы данных (в примере специально было произведено такое действие, вызвавшее исключение, и решением стало удаление файлов миграции, в которых отражалось создание новой, первичной таблицы и указания внешнего ключа во вторичной таблице; т.е. был произведен откат базы).
В поле title модели Category указываем db_index=True для индексации записей, что обеспечивает ускоренный поиск по БД (поле с первичным ключом имеет такой индекс по умолчанию). 

Вносим дополнения и изменения в настройку административной части:
# admin.py
...
class NewsAdmin(admin.ModelAdmin):
    ...
    list_editable = ('is_published', ) # список редактируемых полей (вместо цветовых индикаторов появляются чек-боксы)
    list_filter = ('is_published', 'category') # список полей для фильтрации (справа появляется боковая панель "Фильтр")

class CategoryAdmin(admin.ModelAdmin):
    list_display = ('id', 'title')
    list_display_links = ('id', 'title')
    search_fields = ('title',)
...
admin.site.register(Category, CategoryAdmin)


Урок 14. Внешний вид шаблона
----------------------------
Подключаем bootstrap (getbootstrap.com) через cdn-ссылку (обеспечивает подкачку версии фреймворка через сеть доставки контента). Для этого просто копируем код Starter template (правый сайдбар) и вставляем в нужный html-файл (например, index.hmtl).
Настраиваем бутстрап-шаблон под логику сайта: вносим в него директивы, тэги и фильтры. Интересен момент отображения данных, получаемых вторичной моделью от первичной модели через внешний ключ:
# index.html
...
{% for item in news %}
  <p>{{ item.category }}</p>
...
Здесь будет отображаться название категории, но только потому, что в первичной модели прописан метод __str__ (т.е. вторичная модель, из которой получены данные в news, получает данные по полю category от первичной модели, в которой определено это значение). Если бы этот метод не был бы определен, следовало бы обращаться с указанием поля первичной модели (item.category.title).


Уроки 15 и 16. Директивы, теги и фильтры (Часть 1 и Часть 2)
------------------------------------------------------------
В шаблонах можно обращаться не только к атрибутам, но и методам
# models.py
...
class News(models.Model):
...
    def my_func(self):
        return 'Hello from model'
...
# index.html
...
{% for item in news%}
  <p>{{ item.my_func }}</p>
...

Тэг {{% autoescape %}} контролирует авто-экранирование, т.к. по умолчанию html-тэги в шаблонах экранируются (в целях безопасности и  борьбы с инъекциями):
{% autoescape off %}
  <p class="content">{{ item.content }}</p>
{% endautoescape %}

{% comment %} Здесь закомментированный код {% endcomment %}

{% cycle %} - чередует расцветку строк при выводе данных в цикле
<h5 class="card-title" {% cycle 'text-danger' text-success' %}>...</h5>

{% for item in news reversed %} - выводит объекты в обратном порядке
  {{ forloop.counter }} - выводит номер текущей итерации цикла начиная с 1
  ...
  {% empty %} - выводит сообщение, если не находится искомых объектов
  <li>Sorry, no items in the list.</li>
{% endfor %}

{% if ... %}; {% elif ... %}; {% else %}; {% endif %} - тэги ветвления
{% if client_list and staff_list or total_list %} - код в Django
  ...
if (client_list and staff_list) or total_list: - обычный нативный код
    ...
{% lorem [count] [method] [random] %} - генерирует случайный текст

{% now "jS F Y H:i" %} - показывает текущее время в указанном формате

{% if item.photo %}
  <img src="{{ item.photo.url }}" alt="">
{% else %}
  ### lorem images ###

{{ value|date }} - фильтр (преобразователь) форматирования даты

{{ value|first }} - фильтр возвращает первый элемент списка

{{ value|floatformat:3 }} - возвращает число с тремя знакамм после запятой


Глава 17. Параметры в URL-запросах
----------------------------------
Формирование вывода статей по определенным категориям. Название 'category_id' фигурирует в БД, поэтому сначала указываем его в маршруте, а потом передаем в контроллер, где уже переменную с таким названием извлекаем из БД (т.е. в category_id=category_id слева стоит значение поля с таким названием в таблице news в БД, a справа - параметр, переданный в контроллер, для формирования результатов запроса по конкретной записи):
# urls.py
...
path('category/<int:category_id>', get_category),
...
# views.py 
...
def indext(request):
    news = News.objects.all()
    categories = Category.objects.all()
    context = {
        'news': news,
        'title': 'Список новостей',
        'categories': categories,
    }
    return render(request, template_name='news/index.html', context=context)

def get_category(request, category_id):
    news = News.objects.filter(category_id=category_id)
    categories = Category.objects.all()
    category = Category.get(pk=category_id)
    return render(request, 'news/category.html', {'news': news, 'categories': categories, 'category': category})

# index.html
...
<a href="/">HomePage</a>
...
{%  for item in categories %}
  <a href="/category/{{ item.pk }}">{{ item.title }}<a/>
{% endfor %}
...
{% for item in news %}
  Категория {{ item.category }}
  <p> {{ item.title }}</p>
  <p> {{ item.content }}</p>
...

# category.html
...
{{ category.title }} - указан в заголовке страницы
...
В этом файле код будет примерно таким же, как и в index.html, но выводиться данные будут только по определенной категории, потому что в контроллере формируется сокращенный объект запроса, ограниченный номером категории.


Глава 18. Имена маршрутов
-------------------------
Даем имена маршрутам:
# urls.py
...
path('', index, name='home'),
path('categories/<int:category_id>', get_category, name='category'),
...

# index.html
...
<a href="{% url 'home' %}">HomePage</a>
...
{% for item in categories %}
  <a href="{% url 'category' item.pk %}">{{ item.title }}</a>
...
{% for item in news %}
  <a href="{% url 'category' item.category.pk %}">{{ item.category }}</a>
...

# category.html
...
{% for item in categories %}
  <a href="{% url 'category' item.pk %}">{{ item.title }}</a>
...
{% for item in  news %}
  Категория: {{ item.title }}
...


Глава 19. Наследование шаблонов
-------------------------------
Структура файлов и папок для  хранения шаблонов на данный момент:
mysite
     |
      config -> ...
      news -> templates -> news -> [index.html, category.html]
      templates -> base.html 
               |         
                inc -> [_nav.html]

# base.html
{% include  'inc/_nav.html' %}
{% block sidebar %}SIDEBAR{% endblock %}
{% block  content %}CONTENT{% endblock %}

# _nav.html
<nav class=...
<a class='navbar-brand' href="{% url 'home' %}">Новостной сайт</a>
...
<ul class="navbar-nav mr-auto">
  <li class="nav-item"><a class="nav-link" href="{% url 'home' %}">Главная</a></li>
  <li class="nav-item"><a class="nav-link" href="{% url 'home' %}">Добавить новость</a></li>
</ul>
...
</nav>


Глава 20. Пользовательские теги шаблона
---------------------------------------




