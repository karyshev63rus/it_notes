Ctrl+Shift+T - открывает новую вкладку в терминале
-----N - открывает новое окно в терминале
-----W - закрывает вкладку в терминале
-----Q - закрывает все окна в терминале
Alt+1, 2, 3, ... - переход на вкладки №№ 1, 2, 3, ...

bash - начать новую сессию
uname - выводит имя ОС
date - выводит дату
mkdir -p dir1/dir2/dir3 - создает директории рекурсивно
ls -RA - рекурсивное отображение содержимого директорий со скрытыми файлами
tab - кратное нажатие как вызов автодополнения и подсказок, чем можно дополнить (варианты дополнения)
cd без аргумента - возвращает в домашнюю директорию
сd - - возвращение в предыдущую директорию
rmdir dir1 - удаление пустой директории
rm -r dir1 - удаление директории рекурсивно (т.е. со всем содержимым)
rm -r ./* - удаление всего содержимого из текущей папки
ключ -i будет выводить запрос на удаление (например, rm -ri dir_1)
cp -r dir1 dir2 - копирование dir1 в dir2 рекурсивно (а по-другому никак)
type <smth command> - возвращает инфу о программе (внутренняя она или внешняя, например, среди простейших команд только cd - внутренняя команда, остальные - как правило, просто исполняемые файлы) 
echo text - выведет text
echo $PATH - выведет пути, по которым система будет искать исполняемый файл
echo $HISTSIZE - выведет число последних команд, запоминаемых bash
which <smth command> - выведет путь к исполняемому файлу <команде>
root (UID(0)) - суперпользователь, имеет UID 0.
cat - выводит содержимое файла на экран (например, cat /etc/passwd - здесь  хранится информация о пользователе)
cat -n file - выведет файл с указанием нумерации строк
команда cat может принимать более одного файла и выводить их содержимое в один лист (например, cat file_1 file_2)
root:x:0:0:root:/root:/bin/bash - имя пользователя <root> : пароль <x> : UID <user identificator - 0> : GID <group identificator - 0>: комментарий <здесь - root> : домашний каталог пользователя </root> : командная оболочка пользователя </bin/bash>
/etc/group - здесь хранится информация о группе
id mick - выводит информацию о пользователе из двух вышеуказанных файлов
sudo usermod -aG <name group> <name user> - включить пользователя в группу
/etc/shadow - хранит данные хэша паролей
хэш-функция не имеет обратного преобразования
chmod <u, g, o> + или - <r, w, x> file - изменить права (добавить или убрать) для пользователя, группы или остальных на чтение, запись и исполнение файла
например: chmod u+rwx,g-x+rw,g-rwx file
для директории используем ключ -R для рекурсивного прохождения
файл - именованная область данных на диске
файловая система - метод хранения данных на диске
stat <filename> - информация о хранении файла (в т.ч. блоке)
ls -li - показывает номера inode (i-ноды) файлов (дескрипторов,т.е. описателей файлов; по-другому, место хранения метоинформации о файле)
df - показывает свободное пространство файловых систем
df -i - покажет число i-нодов
удаление файла - это удаление его имени из каталога
ln file file_like_hard_link - создание хард-линка на файл (по сути, ls выводит названия файлов, которые и являются хард-линками на файлы. Это еще одна запись в каталоге о файле)
lh -s file file_soft_link - создание софт-линка, т.е. ярлыка файла или каталога (а хард-линки не могут создаваться на каталоги)

grep - global  regular expressions print
например, ищем строки со словом "install" в файле dpkg.log: grep "install" /var/log/ dpkg.log
поиск посредством команды grep: grep шаблон файл
ключ -i позволит игнорировать различие между строчными и прописными буквами 
grep -v - возвращает только несовпавшие строки
grep -c - возвращает количество совпавших строк
grep -R pattern dir/ - рекурсивных поиск шаблона pattern по директории dir
grep -Re test[12] . - поиск по шаблону (будут найдены все строки, содержащие подстроки "test1" и "test2") начиная с текущей директории

find - поиск файлов по имени и другим свойствам (find папка ключи)
find dir -name pattern (например, find . -name first_file); так же для поиска по части имени файла используется *
find . -type d - будут найдены все директории от этой папки
find . -type d -name "one" - найдутся все директории со вхождением в имя "one"
find . -name "*t*" - найдется все файлы, содержащие в имени букву t
find -delete - удаляет найденные файлы (например, find . -name "*.mp3") -delete
при добавлении ключа -print будут выведены на экран удаленные файлы

ping - утилита для проверки целостности и качества соединений
ping google.com - отправляет пакеты на сайт и выводит итоговую статистику
ключи: 
-с <число пакетов> - определяет число запросов (число пакетов) к отправке
- i <число секунд> - определяет паузы между отправками пакетов
-a - включает звуковой сигнал во время отравки пакета

curl - утилита для обращения к сайту
curl https://example.com - в ответ будет получен html-файл
curl -L ya.ru - перенаправление на сайт яндекса (для это здесь ключ)
-verbouse - ключ для вывода дополнительной информации
curl -X POST ... - отправляет post-запросы
curl -H ... - отправляет хедэры

ssh - команда, работающая по одноименному протоколу, позволяющая работать на удаленных машинах
ssh пользователь@сервер - доступ на удаленный сервер
scp - команда, позволяющая копировать что-то с удаленного сервера или обратно
scp пользователь@сервер:/папка/файл  папка - копирование с удаленной машины
spc testuser@ssh.tearnqa.ru:/home/testuser/test.txt .
scp папка/файл пользователь@сервер:/папка - копирование на удаленную машину
scp test.txt testuser@ssh.learnqa.ru:/home/tesuser/test3.txt

sed - утилита для потокового изменения текста (потоковый текстовый редактор)
sed 's/текст/новый_текст/' - замена первой подстроки
echo 123123 | sed's/1/5/' выведет 523123
sed 's/текст/новый_текст/номер_вхождения' - замена первой подстроки по номеру вхождения
echo 123123 | sed's/1/5/2' выведет 123523
sed 's/текст/новый_текст/g' - заменит все подстроки
echo 123123 | sed's/1/5/g' выведет 523523
sed 's/текст/новый_текст/' файл - замена подстрок в файле
sed s/test/Hello/ my.file - сам файл остался неизменным, т.к. вывод ушел в консоль, но можно вывести результат в отдельный файл, перенаправив вывод
sed s/test/Hello/ my.file >> hello.file
замена в определенной строке: sed "3 s/test/hello" my.file
замена по двуи шаблонам: sed "s/текст/текст1/;s/текст2/текст3/"
sed 's/test/hello/;s/9/000' my.file
запись результата в файл: sed "s/текст/текст1/w файл_записи" файл
sed 's/test/helloworld/w new.file' my.file
sed -f файл_с_командами файл - команды sed транслируются из файла и применяются к содержимому другого файла

awk - команда для обработки табличных значений
awk '{print $номер}' - вывод подстроки по номеру (если 0 - выводит всю строку, по дефолту считает разделителем пробел)
echo "first second" | awk '{print $2}' - выводит second
echo "this,is,a,table" | awk '{print $1}' - выведет всю строку (т.к. не задан формат разделителя)
echo "this,is,a,table" | awk -F, '{print $1}' - теперь выведет this
формат разделителя ';' требует экранирования \; (awk -F\;)
awk '{$номер=текст}' - замена подстроки по номеру
echo "first second" | awk '$1="one"; print $1' - выведет one

xargs - команда, берущая данные из стандартного ввода или файла, разбивающая их в соответствии с указанными параметрами и передающая другой программе в качестве аргументов
команда | xargs ключи команда2
echo file1 file2 | xargs cat - выведется содержимое этих файлов
ls | sort -n | xargs cat - выведется объединенный текст отсортированных файлов директории (удобнее, чем писать cat file1 file2 file3 ...)
sort -r - сортирует в обратном порядке (например, ls | sort -r
find . -name '*.new_file' | xargs cat - находит файлы по шаблону и т.д.
grep this -R | awk -F: '{print $1}' | sort -n | xargs cat - ищет строки со словом this в файлах рекурсивно, далее выводит названия файлов (это то самое первое вхождение), после чего сортирует по названию файлов и выводит содержимое этих файлов
grep 6 -R | awk -F: '{print $1}' | sort -n | xargs cat - вывод по цифре 6
пингуем по списку: 
echo "google.com ya.ru bing.com go.mail.ru" > adds.file
cat adds.file | xargs -n 1 ping -c 1

head -n 4 <filename> - выводит первые n (здесь - 4) строк файла
tail -n 4 <filename> - выводит последние n (здесь - 4) строк файла
ключ -f для команды tail выводит в реальном времени новые записи в лог 
more - просмотр файла, листая клавишей Enter
less - листать можно не только Enter, но и стрелками. Поиск по слову: нажимаем / и пишем слово.
ls -l 1> stdout - перенаправление стандартного потока вывода STDOUT с результатами команды ls -l в файл stdout
le 2> stderr - перенапраавение стандартного потока ошибок STDERR с результатами несуществующей команды le (выдает ошибку) в файл stderr
ls -l asdf ./ 2>stderr 1>stdout - перенаправляем потоки одновременно (записи будут в обоих файлах,так как указаны и несуществующий, и существующий каталоги)
>> - добавляют новые записи в файл
Конвейеры: cat stdout | grep ^- | grep rw - из файла stdout находим строки с началом "-" и подстрокой "rw"
./ - указание текущего каталога
tee - перенаправляет входной поток на два потока: в файл и на экран
ls -l | tee file - запишет (перезапишет) в файл результат стандртного потока вывода
ls -l | tee -a file - добавит (дозапишет) в файл вывод stdout
Перенаправление потоков: ls -l ./ asdf 1> file 2>&1 - оба потока запишутся в один файл file
ls -l asdf 2>&1 | grep asdf - выведет строку с 'asdf'
/dev/null - специальное устройство, которое подавляет вывод (перенаправленный поток уходит в никуда)

ls -l asdf 2>&1 1> /dev/null | grep asdf - выведет сообщение из stderr
ls -l asdf 2>&1 1> /dev/null | grep commons - ничего не выведет (commons - это имя одного из файлов в отчетном каталоге)
$? - переменная, которая содержит код возврата последней выполненной команды
echo $? - вывод на экран значения этой переменной (к примеру, если напечатать просто $? - код возврата будет 127)
ls -l && echo Ok - логическое И (&&) - если первая команда не сработает, то выведется ошибка и до второй команды дело не дойдет
ls -l || echo ERR - логическое ИЛИ (||) - выполнится либо первая, либо (если она не сработает) вторая команда, т.е. пока код возврата не станет равен нулю, логическое ИЛИ передает управление следующей команде
ls -l ; echo no OK - оператор "не имеет значения" (;), т.е. вторая команда будет выполнена в любом случае
оператор ';' позволяет написать скрипт в одну строку, без создания отдельного файла
Логические операторы работают на основании кода возврата программы
mount /dev/sda /mnt - команда монтирования (что монтируем и куда монтируем)
umount /mnt/ - команда размонтирования (аргумент - где монтировали)
umount /dev/sda - то же (аргумент - что монитровали)
/proc/self/mounts - файл, содержащий информацию о точках монтирования
/etc/fstab - файл,  описывающий точки монтирования при старте ОС
wc -l - в конвейре считает строки файла, например, содержащие подстроку
wc без ключа отображает количество строк, слов и байтов в файле (по искомому слову)

процесс - работающая в данный момент программа
процесс - совокупность действий, преобразующих входящие данные в исходящие
процесс - совокупность программного кода и ресурсов для его выполнения
зум экрана: уменьшить - ctrl + '-', увеличить - ctrl + shift + '=' (т.е. '+')
демон - программа, запускаемая самой системой и работающая в фоновом режиме без прямого взаимодействия с пользователем
демон - процесс, который не имеет управляющего терминала

ps - утилита для выведения процессов - команда отобразит процессы пользователя, запущенные в этом открытом терминале
ключи команды ps: 
x (без минуса, т.е. ps x) - процессы, отсоединенные от терминала
u  - процессы, принадлежащие данному пользователю
au - процессы по всем пользователям
aux - все процессы
-е - отобразить все процессы; 
-f - вывести полную информацию; 
-l - это long (что имеется в виду? выведение не только имени, но и другой информации?)

top - выводит потребление процессами процессорного времени. Это динамическая утилита, поэтому, если нажать на s, то можно задать период обновления состояния (изначально - 3 секунды)
load average - характеризует степень загрузки процессора, показывает количество (долю?) процессов в очереди за 1 мин, за 5 мин, за 15 мин
нажатие на 1 выведет на экран данные по каждому из ядер процессора
Tasks - процессы (total, running, sleeping, stopped, zombie)
%Cpu(s) параметры: 
us - сколько процессорных ресурсов было израсходовано в пространстве пользователя
sy - -\- на работу ядра операционной системы
ni - -\- на процессы с пониженным приоритетом (показатель-аттавизм, т.к. есть столбец PR с номерами приоритетов процессов - чем ниже значение (по умолчаниюравно 20), тем выше приоритет. Кстати, рядом столбец NI)
id - процент простоя процессорного времени (если 100 - процессо не загружен)
wa - сколько процессорного времени было потрачено на общение с устройствами ввода-вывода
hi - сколько процессорных ресурсов было потрачено на обработку аппаратных прерываний
si - программное прерывание (системные вызовы)
st - для виртуальных машин, показывает как загружена хостовая машина
fork() - создание нового процесса
zombi - просто строчка в таблице процессов
ip a - вывод данных об ip-адресах компьютера (какой ip-адрес назначен на нашем сервере)
ip r - выводит информацию, какие маршруты есть на нашем сервере
/etc/resolv.conf - здесь хранится информация о сервере имен (dns-сервере)
ss -tnlp - выводит, какие службы по каким портам что-то делают
kill - команда завершения процесса
kill -9 <номер процесса> - немедленное завершение процесса
kill -15 <номер процесса> - штатное завершение процесса
kill -l - выводит номера вариантов завершения процессов

$имя - переменная окружения; передается в программу при запуске
содержат общие настройки системы, параметры командной и графической оболочки, место размпещения исполняемых файлов, имя любимого тестового редактора или настройки локали
a="Hello World"; echo $a - живет только в этой сессии и в другие не передается
export a="Hello World"; echo $a - появится в других сессиях, пока жива исходная сессия
создание резервной копии конфига: cat ~/.bashrc >> .bashrc_bak
echo 'echo "Hello world for every bash session"' >> ~./bashrc


редакторы nano и vi
vi: i - вход в режим правки (появляется знак -- INSERT --)
ESC - выход из режима редактирования
:w - сохранение файла
:q - выход из редактора (в случае сохраненного файла)
:q! - выход без сохранения
:n - переход на строку номер n
в командном режиме:
/word - поиск по слову word (каретка будет установлена на слове word)
dd - удаление строки
:u - отменить последнее изменение

PATH="/home/mick/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/usr/lib/jvm/java-8-oracle/bin:/usr/lib/jvm/java-8-oracle/db/bin:/usr/lib/jvm/java-8-oracle/jre/bin"
ME=$(whoami)" :}"; echo $ME - выведет имя пользователя и смайлик <username> :)

собираем данные с сайта и записываем в файл командой:
curl -sL https://habr.com/top | grep post__title_link >> habr.top
создаем для этой команды псевдоним:
alias habr='curl -sL https://habr.com/top | grep post__title_link >> habr.top
'
записать псевдоним в конфиг-файл: echo "alias  gs='git status'" >> ~/.bashrc
после этого закрепить командой: source ~/.bashrc

history - команда для отображения истории команд
!! - команда, которая повторяет последнюю команду из истории команд
например, ввели whoami и забыли sudo. Вводим sudo !!
или ввели ls, но решили посмотреть скрытые файлы. Вводим !! -a
!-n возможность ввести команду номер n от конца истории команд
Ctrl + R - поиск команды по ее части

Настройка переменной строки приглашения к вводу (прописывается в .bashrc):
gitPS1(){
    gitps1=$(git branch 2>/dev/null | grep '*')
    gitps1="${gitps1:+ (${gitps1/#\* /})}"
    echo "$gitps1"
}
PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\[\033[1;36m\]$(gitPS1)\[\033[00m\] \[\033[1;37m\]:/$\[\033[00m\] '

set | less - отображение всех переменных среды
watch 'cat /proc/loadavg' - наблюдение за выполнением команды (здесь - как создается средняя нагрузка)
env - вывести на экран переменные среды своего bash
chmod u+x myscript.sh - файл myscript.sh получаем статус выполнеяемого
#! /bin/bash - обязательно первая строка выполняемого файла

пример сценария с условием:
if [ MYSTRING=abc ]
then
echo 'It is my sting!'
fi

Команда compgen дает возможность определить, какие команды (ключ -c), функции (-b) и перечерь ключевых слов (-k) доступны юзеру.

команда tee с ключом -a дописывает данные в файл (ls | tee -a file_ls)
jobs - команда для просмотра процессов, запущенных в фоновом режиме
fg 1 - вывод задачи в приоритет из фонового режима
Ctrl + Z - приостановка работы процесса в фоновом режиме

chmod 755 file.sh - вариант смены режима файла (на -rwxr-xr-x)

#!/usr/bin/env bash - стандартный способ  решения проблемы мобильности нахождения местоположения команды bash для запуска того скрипта, в котором сделана эта запись. Но при этом запуск файла вариантом ./filename.sh не получится, придется писать bash filename.sh

printf "Hello world\n" - встроенная команда, позволяющая добавлять форматирование

echo "$x" выведет значение переменной x, а echo '$x' - просто выведет $x

CMDOUT=$(pwd) - можно сохранить в переменной вывод команды или целого ряда команд

Передача аргументов файлу и вывод их при исполнении файла:
echoparams.sh

!#/bin/bash -

echo $#
echo $1
echo $2
echo $3

делаем файл исполняемым и вызываем его: bash echoparams.sh one two three и увидим 3 one two three

less - при использовании команды можно нажать клавишу "v" и перейти в режим редактирования документа (он откроется в редакторе, здесь в nano)

for LS in $(ls); do $LS; done - напечатает содержимое текущей директории
for NUM in $(cat file_with_numbers_in_each_string); do echo $NUM; done

Если установка пакетов оканчивается с ошибкой 1, возможно проблему в том, что какие-то ранее устанававливаемые пакеты не были установлены до конца. В этом случае далаем так:
sudo dpkg --configure -a - команда может сообщить о таких проблемных пакетах
sudo apt remove --purge ПРОБЛЕМНЫЙ-ПАКЕТ - тогда сносим этот проблемный пакет
sudo apt install ПРОБЛЕМНЫЙ-ПАКЕТ - а затем может поставить его обратно
sudo apt install --reinstall ПРОБЛЕМНЫЙ-ПАКЕТ - если это не помогает, вводим эту команду
Если совсем край, то открываем файл vim /var/lib/dpkg/status, находим таи инфу по проблемному пакету и удаляем ее.




/var/cache/apt/archives/ - местоположение пакетов apt

diff -y file_1 file_2 - вывод  сравниваемых файлов в две колонки

вывод на печать содержимого директории (пытаемся прочесть каждый файл и вложенную директорию, что в последнем случае, невозможно) или файла (читаем его строки) в цикле:
for i in $(ls ~/my_dir); do cat $i; done (соответственно, если текущая папка, то берем ls)
for k in $(cat my_file); do echo $k; done

tar -cvf filename.tar archivated_dir - создание архива filename.tar на основе данных папки archivated_dir
tar -tvf filename.tar - просмотр заголовков архива
tar -xvf filename.tar destination_dir - разархивирование файла в директорию distenation_dir

tar -cvf - ./archivated_dir | gzip -c >  filename.tar.gz - применение конвейера из архиватора и компрессора

tar -cjvf archive.tar.bz2 file1 file2 - архивирование и сжание при помощи утилиты bz2
tar -czvf archive.tar.gz file1 file2 - то же, но при помощи утилиты gz2

tar -C "Test" -xjvf archive.tar.bz2 - распаковка архива с таким расширением (bz2)
tar -xzvf archive.tar.gz - распаковка  архива с расширением gz


du -sh /home/mick -показывает объем занятого места в памяти

crontab -e - создать файл планировщика cron

grep -v pattern file - выдаст все строки в file, что не соответствуют pattern

grep -v ^# configfile_with_comments > configfile_without_comments - убираем из файла многочисленные комментарии (если строки начинаются с #, если же есть отступы, то шаблон будет такой: -v "#")

apt-cashe search server - программа apt-cashe ищет в репозитории пакет с именем, включащим слово server

systemctl status nginx - узнаем статус сервера (но главное здесь, это systemctl - через нее можно узнать о многом ногое сделать; например, команда systemctl start nginx запустит сервер)

netstat -tnlp - команда выведет список активных интернет-соединенй, (т.е.занятых портов, а именно какой процесс на каком порту слушает и т.д.)

/etc/hosts

nslookup localhost

/etc/resolv.conf

man awk

id - узнать, в какой группе состоит пользователь (который эту команду и вводит)

/etc/passwd /etc/shadow /ect/group /etc/gshadow (в последнем хранятся хэши паролей групп) /etc/sudoers

grep ^root /etc/* 2> /dev/null - не будут выведены ошибки при попытках прочитить директории как файл

find . -type d - вывести все директории текущей директории

/etc/crontab - это системный файл crontab

crontab -e - создать персональный файл crontab

15 8 * * Mon,Tue,Wed.Thu,Fri mail chris < /var/project/stats.txt - здесь пользователю Chris посылается письмо, в которое направляется содержимое вышеуказанного каталога; эта команда выполняется с понедельника по пятницу в 8:15 утра.

uname -r - отобразить имя выпуска ядра
uname -a - отобразить всю доступную информацию о ядре
free - показывает объем свободной памяти (?)

netstat -i - получить статистику о сетевом интерфейсе

ifconfig - выводит информацию о сетевых интерфейсах (с адресами, трафиком и т.д.)
ifconfig -a - дает информацию как об активных, так и неактивных сетевых интерфейсах

ip addr или ip a - дает схожую информацию о сетевых интерфейсах

iwconfig - дает информацию о беспроводных сетевых интерфейсах

elinks - браузер, работающий в терминале (пока непонятно, как им пользоваться)

 им пользоваться

wget - утилита для загрузки файлов и страниц из сети

Файловая система /proc, первоначально нужная для хранения информации, используемой запущенными процессами, основное место размещения всевозможной информации, используемой ядром linux

cat /proc/version - показать номер версии ядра и соответствующего компилятора

Новая настройка строки-приглашения к вводу (меняем и для пользователя, и для рута - в последнем случае меняем $ на #) вместе с опцией указания ветки git (соответственно, получается  mick ~$ и root ~#):

gitPS1(){
    gitps1=$(git branch 2>/dev/null | grep '*')
    gitps1="${gitps1:+ (${gitps1/#\* /})}"
    echo "$gitps1"
}

PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u \[\[\033[01;34m\]\w\[\033[00m\]\[\033[1;36m\]$(gitPS1)\[\033[00m\]\[\033[1;37m\]$\[\033[00m\] '

пользовательский фон терминала имеет цветовой номер #042433

ps aux | grep mick | cut -d ' ' -f 2-10 - выведет номера процессов, запущенных от имени пользователя mick

ps aux | firefox | cut -d ' ' -f 2-10 > pid_firefox; for i in $(cat  pid_firefox); do kill $i; done  - определяем  номера процессов, связанных с программой firefox, и убиваем их

docker images | awk '{ if($1=="<none>") print $3}' - команда выведет id всех "бесхозных" контейнеров (которые имеют имя <none>)

