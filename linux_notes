Ctrl+Shift+T - открывает новую вкладку в терминале
-----N - открывает новое окно в терминале
-----W - закрывает вкладку в терминале
-----Q - закрывает все окна в терминале
Alt+1, 2, 3, ... - переход на вкладки №№ 1, 2, 3, ...

bash - начать новую сессию
uname (uname -a) - выводит имя ОС
date - выводит дату
mkdir -p dir1/dir2/dir3 - создает директории рекурсивно
ls -RA - рекурсивное отображение содержимого директорий со скрытыми файлами
tab - кратное нажатие как вызов автодополнения и подсказок, чем можно дополнить (варианты дополнения)
cd без аргумента - возвращает в домашнюю директорию
сd - - возвращение в предыдущую директорию
rmdir dir1 - удаление пустой директории
rm -r dir1 - удаление директории рекурсивно (т.е. со всем содержимым)
rm -r ./* - удаление всего содержимого из текущей папки
ключ -i будет выводить запрос на удаление (например, rm -ri dir_1)
cp -r dir1 dir2 - копирование dir1 в dir2 рекурсивно (а по-другому никак)
type <smth command> - возвращает инфу о программе (внутренняя она или внешняя, например, среди простейших команд только cd - внутренняя команда, остальные - как правило, просто исполняемые файлы) 
echo text - выведет text
echo $PATH - выведет пути, по которым система будет искать исполняемый файл
echo $HISTSIZE - выведет число последних команд, запоминаемых bash
which <smth command> - выведет путь к исполняемому файлу <команде>
root (UID(0)) - суперпользователь, имеет UID 0.
cat - выводит содержимое файла на экран (например, cat /etc/passwd - здесь  хранится информация о пользователе)
cat -n file - выведет файл с указанием нумерации строк
команда cat может принимать более одного файла и выводить их содержимое в один лист (например, cat file_1 file_2)
root:x:0:0:root:/root:/bin/bash - имя пользователя <root> : пароль <x> : UID <user identificator - 0> : GID <group identificator - 0>: комментарий <здесь - root> : домашний каталог пользователя </root> : командная оболочка пользователя </bin/bash>
/etc/group - здесь хранится информация о группе
id mick - выводит информацию о пользователе из двух вышеуказанных файлов
sudo usermod -aG <name group> <name user> - включить пользователя в группу
/etc/shadow - хранит данные хэша паролей
хэш-функция не имеет обратного преобразования
chmod <u, g, o> + или - <r, w, x> file - изменить права (добавить или убрать) для пользователя, группы или остальных на чтение, запись и исполнение файла
например: chmod u+rwx,g-x+rw,g-rwx file
для директории используем ключ -R для рекурсивного прохождения
файл - именованная область данных на диске
файловая система - метод хранения данных на диске
stat <filename> - информация о хранении файла (в т.ч. блоке)
ls -li - показывает номера inode (i-ноды) файлов (дескрипторов,т.е. описателей файлов; по-другому, место хранения метоинформации о файле)
df - показывает свободное пространство файловых систем
df -i - покажет число i-нодов
удаление файла - это удаление его имени из каталога
ln file file_like_hard_link - создание хард-линка на файл (по сути, ls выводит названия файлов, которые и являются хард-линками на файлы. Это еще одна запись в каталоге о файле)
lh -s file file_soft_link - создание софт-линка, т.е. ярлыка файла или каталога (а хард-линки не могут создаваться на каталоги)

file - утилита для получения характеритики файла, например:
file .bashrc выведет сообщение .bashrc: ASCII text, with very long lines
grep - global  regular expressions print
ps aux | grep 'celery worker' | grep -v grep - из выдачи будет исключен сам этот запрос (мы знаем, что он есть и он нам не нужен)
например, ищем строки со словом "install" в файле dpkg.log: grep "install" /var/log/ dpkg.log
поиск посредством команды grep: grep шаблон файл
ключ -i позволит игнорировать различие между строчными и прописными буквами 
grep -v - возвращает только несовпавшие строки
grep -c - возвращает количество совпавших строк
grep -R pattern dir/ - рекурсивных поиск шаблона pattern по директории dir
grep -Re test[12] . - поиск по шаблону (будут найдены все строки, содержащие подстроки "test1" и "test2") начиная с текущей директории

find - поиск файлов по имени и другим свойствам (find папка ключи)
find dir -name pattern (например, find . -name first_file); так же для поиска по части имени файла используется *
find . -type d - будут найдены все директории от этой папки
find . -type d -name "one" - найдутся все директории со вхождением в имя "one"
find . -name "*t*" - найдется все файлы, содержащие в имени букву t
find -delete - удаляет найденные файлы (например, find . -name "*.mp3") -delete
при добавлении ключа -print будут выведены на экран удаленные файлы
ключ -maxdepth n - определяет глубину поиска на n уровней вглубь
find it_notes -name "*notes" - выведет все файлы, содержащие в окончании названия notes 
если прибавить ключ -not: it_notes -not -name "*notes" - выведет все файлы, не оканчивающиеся на notes

ping - утилита для проверки целостности и качества соединений
ping google.com - отправляет пакеты на сайт и выводит итоговую статистику
ключи: 
-с <число пакетов> - определяет число запросов (число пакетов) к отправке
- i <число секунд> - определяет паузы между отправками пакетов
-a - включает звуковой сигнал во время отравки пакета

curl - утилита для обращения к сайту
curl https://example.com - в ответ будет получен html-файл
curl -L ya.ru - перенаправление на сайт яндекса (для это здесь ключ)
-verbouse - ключ для вывода дополнительной информации
curl -X POST ... - отправляет post-запросы
curl -H ... - отправляет хедэры

ssh - команда, работающая по одноименному протоколу, позволяющая работать на удаленных машинах
ssh пользователь@сервер - доступ на удаленный сервер
scp - команда, позволяющая копировать что-то с удаленного сервера или обратно
scp пользователь@сервер:/папка/файл  папка - копирование с удаленной машины
spc testuser@ssh.tearnqa.ru:/home/testuser/test.txt .
scp папка/файл пользователь@сервер:/папка - копирование на удаленную машину
scp test.txt testuser@ssh.learnqa.ru:/home/tesuser/test3.txt

sed - утилита для потокового изменения текста (потоковый текстовый редактор)
sed 's/текст/новый_текст/' - замена первой подстрок
echo 123123 | sed's/1/5/' выведет 523123
sed 's/текст/новый_текст/номер_вхождения' - замена первой подстроки по номеру вхождения
echo 123123 | sed's/1/5/2' выведет 123523
sed 's/текст/новый_текст/g' - заменит все подстроки
echo 123123 | sed's/1/5/g' выведет 523523
sed 's/текст/новый_текст/' файл - замена подстрок в файле
sed s/test/Hello/ my.file - сам файл остался неизменным, т.к. вывод ушел в консоль, но можно вывести результат в отдельный файл, перенаправив вывод
sed s/test/Hello/ my.file >> hello.file
замена в определенной строке: sed "3 s/test/hello" my.file
замена по двуи шаблонам: sed "s/текст/текст1/;s/текст2/текст3/"
sed 's/test/hello/;s/9/000' my.file
запись результата в файл: sed "s/текст/текст1/w файл_записи" файл
sed 's/test/helloworld/w new.file' my.file
sed -f файл_с_командами файл - команды sed транслируются из файла и применяются к содержимому другого файла

awk - команда для обработки табличных значений
awk '{print $номер}' - вывод подстроки по номеру (если 0 - выводит всю строку, по дефолту считает разделителем пробел)
echo "first second" | awk '{print $2}' - выводит second
echo "this,is,a,table" | awk '{print $1}' - выведет всю строку (т.к. не задан формат разделителя)
echo "this,is,a,table" | awk -F, '{print $1}' - теперь выведет this
формат разделителя ';' требует экранирования \; (awk -F\;)
awk '{$номер=текст}' - замена подстроки по номеру
echo "first second" | awk '$1="one"; print $1' - выведет one

xargs - команда, берущая данные из стандартного ввода или файла, разбивающая их в соответствии с указанными параметрами и передающая другой программе в качестве аргументов
команда | xargs ключи команда2
echo file1 file2 | xargs cat - выведется содержимое этих файлов
ls | sort -n | xargs cat - выведется объединенный текст отсортированных файлов директории (удобнее, чем писать cat file1 file2 file3 ...)
sort -r - сортирует в обратном порядке (например, ls | sort -r
find . -name '*.new_file' | xargs cat - находит файлы по шаблону и т.д.
grep this -R | awk -F: '{print $1}' | sort -n | xargs cat - ищет строки со словом this в файлах рекурсивно, далее выводит названия файлов (это то самое первое вхождение), после чего сортирует по названию файлов и выводит содержимое этих файлов
grep 6 -R | awk -F: '{print $1}' | sort -n | xargs cat - вывод по цифре 6
пингуем по списку: 
echo "google.com ya.ru bing.com go.mail.ru" > adds.file
cat adds.file | xargs -n 1 ping -c 1

head -n 4 <filename> - выводит первые n (здесь - 4) строк файла
tail -n 4 <filename> - выводит последние n (здесь - 4) строк файла
ключ -f для команды tail выводит в реальном времени новые записи в лог 
more - просмотр файла, листая клавишей Enter
less - листать можно не только Enter, но и стрелками. Поиск по слову: нажимаем / и пишем слово.
ls -l 1> stdout - перенаправление стандартного потока вывода STDOUT с результатами команды ls -l в файл stdout
le 2> stderr - перенапраавение стандартного потока ошибок STDERR с результатами несуществующей команды le (выдает ошибку) в файл stderr
ls -l asdf ./ 2>stderr 1>stdout - перенаправляем потоки одновременно (записи будут в обоих файлах,так как указаны и несуществующий, и существующий каталоги)
>> - добавляют новые записи в файл
Конвейеры: cat stdout | grep ^- | grep rw - из файла stdout находим строки с началом "-" и подстрокой "rw"
./ - указание текущего каталога
tee - перенаправляет входной поток на два потока: в файл и на экран
ls -l | tee file - запишет (перезапишет) в файл результат стандртного потока вывода
ls -l | tee -a file - добавит (дозапишет) в файл вывод stdout
Перенаправление потоков: ls -l ./ asdf 1> file 2>&1 - оба потока запишутся в один файл file
ls -l asdf 2>&1 | grep asdf - выведет строку с 'asdf'
/dev/null - специальное устройство, которое подавляет вывод (перенаправленный поток уходит в никуда)

ls -l asdf 2>&1 1> /dev/null | grep asdf - выведет сообщение из stderr
ls -l asdf 2>&1 1> /dev/null | grep commons - ничего не выведет (commons - это имя одного из файлов в отчетном каталоге)
$? - переменная, которая содержит код возврата последней выполненной команды
echo $? - вывод на экран значения этой переменной (к примеру, если напечатать просто $? - код возврата будет 127)
ls -l && echo Ok - логическое И (&&) - если первая команда не сработает, то выведется ошибка и до второй команды дело не дойдет
ls -l || echo ERR - логическое ИЛИ (||) - выполнится либо первая, либо (если она не сработает) вторая команда, т.е. пока код возврата не станет равен нулю, логическое ИЛИ передает управление следующей команде
ls -l ; echo no OK - оператор "не имеет значения" (;), т.е. вторая команда будет выполнена в любом случае
оператор ';' позволяет написать скрипт в одну строку, без создания отдельного файла
Логические операторы работают на основании кода возврата программы
mount /dev/sda /mnt - команда монтирования (что монтируем и куда монтируем)
umount /mnt/ - команда размонтирования (аргумент - где монтировали)
umount /dev/sda - то же (аргумент - что монитровали)
/proc/self/mounts - файл, содержащий информацию о точках монтирования
/etc/fstab - файл,  описывающий точки монтирования при старте ОС
wc -l - в конвейре считает строки файла, например, содержащие подстроку
wc без ключа отображает количество строк, слов и байтов в файле (по искомому слову)

процесс - работающая в данный момент программа
процесс - совокупность действий, преобразующих входящие данные в исходящие
процесс - совокупность программного кода и ресурсов для его выполнения
зум экрана: уменьшить - ctrl + '-', увеличить - ctrl + shift + '=' (т.е. '+')
демон - программа, запускаемая самой системой и работающая в фоновом режиме без прямого взаимодействия с пользователем
демон - процесс, который не имеет управляющего терминала

ps - утилита для выведения процессов - команда отобразит процессы пользователя, запущенные в этом открытом терминале
ключи команды ps: 
x (без минуса, т.е. ps x) - процессы, отсоединенные от терминала
u  - процессы, принадлежащие данному пользователю
au - процессы по всем пользователям
aux - все процессы
-е - отобразить все процессы; 
-f - вывести полную информацию; 
-l - это long (что имеется в виду? выведение не только имени, но и другой информации?)

top - выводит потребление процессами процессорного времени. Это динамическая утилита, поэтому, если нажать на s, то можно задать период обновления состояния (изначально - 3 секунды)
load average - характеризует степень загрузки процессора, показывает количество (долю?) процессов в очереди за 1 мин, за 5 мин, за 15 мин
нажатие на 1 выведет на экран данные по каждому из ядер процессора
Tasks - процессы (total, running, sleeping, stopped, zombie)
%Cpu(s) параметры: 
us - сколько процессорных ресурсов было израсходовано в пространстве пользователя
sy - -\- на работу ядра операционной системы
ni - -\- на процессы с пониженным приоритетом (показатель-аттавизм, т.к. есть столбец PR с номерами приоритетов процессов - чем ниже значение (по умолчаниюравно 20), тем выше приоритет. Кстати, рядом столбец NI)
id - процент простоя процессорного времени (если 100 - процессо не загружен)
wa - сколько процессорного времени было потрачено на общение с устройствами ввода-вывода
hi - сколько процессорных ресурсов было потрачено на обработку аппаратных прерываний
si - программное прерывание (системные вызовы)
st - для виртуальных машин, показывает как загружена хостовая машина
fork() - создание нового процесса
zombi - просто строчка в таблице процессов
ip a - вывод данных об ip-адресах компьютера (какой ip-адрес назначен на нашем сервере)
ip r - выводит информацию, какие маршруты есть на нашем сервере
/etc/resolv.conf - здесь хранится информация о сервере имен (dns-сервере)
ss -tnlp - выводит, какие службы по каким портам что-то делают
kill - команда завершения процесса
kill -9 <номер процесса> - немедленное завершение процесса
kill -15 <номер процесса> - штатное завершение процесса
kill -l - выводит номера вариантов завершения процессов

$имя - переменная окружения; передается в программу при запуске
содержат общие настройки системы, параметры командной и графической оболочки, место размпещения исполняемых файлов, имя любимого тестового редактора или настройки локали
a="Hello World"; echo $a - живет только в этой сессии и в другие не передается
export a="Hello World"; echo $a - появится в других сессиях, пока жива исходная сессия
создание резервной копии конфига: cat ~/.bashrc >> .bashrc_bak
echo 'echo "Hello world for every bash session"' >> ~./bashrc


редакторы nano и vi
vi: i - вход в режим правки (появляется знак -- INSERT --)
ESC - выход из режима редактирования
:w - сохранение файла
:q - выход из редактора (в случае сохраненного файла)
:q! - выход без сохранения
:n - переход на строку номер n
в командном режиме:
/word - поиск по слову word (каретка будет установлена на слове word)
dd - удаление строки
:u - отменить последнее изменение

PATH="/home/mick/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/usr/lib/jvm/java-8-oracle/bin:/usr/lib/jvm/java-8-oracle/db/bin:/usr/lib/jvm/java-8-oracle/jre/bin"
ME=$(whoami)" :}"; echo $ME - выведет имя пользователя и смайлик <username> :)

собираем данные с сайта и записываем в файл командой:
curl -sL https://habr.com/top | grep post__title_link >> habr.top
создаем для этой команды псевдоним:
alias habr='curl -sL https://habr.com/top | grep post__title_link >> habr.top
'
записать псевдоним в конфиг-файл: echo "alias  gs='git status'" >> ~/.bashrc
после этого закрепить командой: source ~/.bashrc

history - команда для отображения истории команд
!! - команда, которая повторяет последнюю команду из истории команд
например, ввели whoami и забыли sudo. Вводим sudo !!
или ввели ls, но решили посмотреть скрытые файлы. Вводим !! -a
!-n возможность ввести команду номер n от конца истории команд
Ctrl + R - поиск команды по ее части

Настройка переменной строки приглашения к вводу (прописывается в .bashrc):
gitPS1(){
    gitps1=$(git branch 2>/dev/null | grep '*')
    gitps1="${gitps1:+ (${gitps1/#\* /})}"
    echo "$gitps1"
}
PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\[\033[1;36m\]$(gitPS1)\[\033[00m\] \[\033[1;37m\]:/$\[\033[00m\] '

set | less - отображение всех переменных среды
watch 'cat /proc/loadavg' - наблюдение за выполнением команды (здесь - как создается средняя нагрузка)
env - вывести на экран переменные среды своего bash
chmod u+x myscript.sh - файл myscript.sh получаем статус выполнеяемого
#! /bin/bash - обязательно первая строка выполняемого файла

пример сценария с условием:
if [ MYSTRING=abc ]
then
echo 'It is my sting!'
fi

Команда compgen дает возможность определить, какие команды (ключ -c), функции (-b) и перечерь ключевых слов (-k) доступны юзеру.

команда tee с ключом -a дописывает данные в файл (ls | tee -a file_ls)
jobs - команда для просмотра процессов, запущенных в фоновом режиме
fg 1 - вывод задачи в приоритет из фонового режима
Ctrl + Z - приостановка работы процесса в фоновом режиме

chmod 755 file.sh - вариант смены режима файла (на -rwxr-xr-x)

#!/usr/bin/env bash - стандартный способ  решения проблемы мобильности нахождения местоположения команды bash для запуска того скрипта, в котором сделана эта запись. Но при этом запуск файла вариантом ./filename.sh не получится, придется писать bash filename.sh

printf "Hello world\n" - встроенная команда, позволяющая добавлять форматирование

echo "$x" выведет значение переменной x, а echo '$x' - просто выведет $x

CMDOUT=$(pwd) - можно сохранить в переменной вывод команды или целого ряда команд

Передача аргументов файлу и вывод их при исполнении файла:
echoparams.sh

!#/bin/bash -

echo $#
echo $1
echo $2
echo $3

делаем файл исполняемым и вызываем его: bash echoparams.sh one two three и увидим 3 one two three

less - при использовании команды можно нажать клавишу "v" и перейти в режим редактирования документа (он откроется в редакторе, здесь в nano)

for LS in $(ls); do $LS; done - напечатает содержимое текущей директории
for NUM in $(cat file_with_numbers_in_each_string); do echo $NUM; done

Если установка пакетов оканчивается с ошибкой 1, возможно проблему в том, что какие-то ранее устанававливаемые пакеты не были установлены до конца. В этом случае далаем так:
sudo dpkg --configure -a - команда может сообщить о таких проблемных пакетах
sudo apt remove --purge ПРОБЛЕМНЫЙ-ПАКЕТ - тогда сносим этот проблемный пакет
sudo apt install ПРОБЛЕМНЫЙ-ПАКЕТ - а затем может поставить его обратно
sudo apt install --reinstall ПРОБЛЕМНЫЙ-ПАКЕТ - если это не помогает, вводим эту команду
Если совсем край, то открываем файл vim /var/lib/dpkg/status, находим таи инфу по проблемному пакету и удаляем ее.




/var/cache/apt/archives/ - местоположение пакетов apt

diff -y file_1 file_2 - вывод  сравниваемых файлов в две колонки

вывод на печать содержимого директории (пытаемся прочесть каждый файл и вложенную директорию, что в последнем случае, невозможно) или файла (читаем его строки) в цикле:
for i in $(ls ~/my_dir); do cat $i; done (соответственно, если текущая папка, то берем ls)
for k in $(cat my_file); do echo $k; done

tar -cvf filename.tar archivated_dir - создание архива filename.tar на основе данных папки archivated_dir
tar -tvf filename.tar - просмотр заголовков архива
tar -xvf filename.tar destination_dir - разархивирование файла в директорию distenation_dir

tar -cvf - ./archivated_dir | gzip -c >  filename.tar.gz - применение конвейера из архиватора и компрессора

tar -cjvf archive.tar.bz2 file1 file2 - архивирование и сжание при помощи утилиты bz2
tar -czvf archive.tar.gz file1 file2 - то же, но при помощи утилиты gz2

tar -C "Test" -xjvf archive.tar.bz2 - распаковка архива с таким расширением (bz2)
tar -xzvf archive.tar.gz - распаковка  архива с расширением gz


du -sh /home/mick -показывает объем занятого места в памяти

crontab -e - создать файл планировщика cron

grep -v pattern file - выдаст все строки в file, что не соответствуют pattern

grep -v ^# configfile_with_comments > configfile_without_comments - убираем из файла многочисленные комментарии (если строки начинаются с #, если же есть отступы, то шаблон будет такой: -v "#")

apt-cashe search server - программа apt-cashe ищет в репозитории пакет с именем, включащим слово server

systemctl status nginx - узнаем статус сервера (но главное здесь, это systemctl - через нее можно узнать о многом ногое сделать; например, команда systemctl start nginx запустит сервер)

netstat -tnlp - команда выведет список активных интернет-соединенй, (т.е.занятых портов, а именно какой процесс на каком порту слушает и т.д.)

/etc/hosts

nslookup localhost

/etc/resolv.conf

man awk

id - узнать, в какой группе состоит пользователь (который эту команду и вводит)

/etc/passwd /etc/shadow /ect/group /etc/gshadow (в последнем хранятся хэши паролей групп) /etc/sudoers

grep ^root /etc/* 2> /dev/null - не будут выведены ошибки при попытках прочитить директории как файл

find . -type d - вывести все директории текущей директории

/etc/crontab - это системный файл crontab

crontab -e - создать персональный файл crontab

15 8 * * Mon,Tue,Wed.Thu,Fri mail chris < /var/project/stats.txt - здесь пользователю Chris посылается письмо, в которое направляется содержимое вышеуказанного каталога; эта команда выполняется с понедельника по пятницу в 8:15 утра.

uname -r - отобразить имя выпуска ядра
uname -a - отобразить всю доступную информацию о ядре
free - показывает объем свободной памяти (?)

netstat -i - получить статистику о сетевом интерфейсе

ifconfig - выводит информацию о сетевых интерфейсах (с адресами, трафиком и т.д.)
ifconfig -a - дает информацию как об активных, так и неактивных сетевых интерфейсах

ip addr или ip a - дает схожую информацию о сетевых интерфейсах

iwconfig - дает информацию о беспроводных сетевых интерфейсах

elinks - браузер, работающий в терминале (пока непонятно, как им пользоваться)

 им пользоваться

wget - утилита для загрузки файлов и страниц из сети

Файловая система /proc, первоначально нужная для хранения информации, используемой запущенными процессами, основное место размещения всевозможной информации, используемой ядром linux

cat /proc/version - показать номер версии ядра и соответствующего компилятора

Новая настройка строки-приглашения к вводу (меняем и для пользователя, и для рута - в последнем случае меняем $ на #) вместе с опцией указания ветки git (соответственно, получается  mick ~$ и root ~#):

gitPS1(){
    gitps1=$(git branch 2>/dev/null | grep '*')
    gitps1="${gitps1:+ (${gitps1/#\* /})}"
    echo "$gitps1"
}

PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u \[\[\033[01;34m\]\w\[\033[00m\]\[\033[1;36m\]$(gitPS1)\[\033[00m\]\[\033[1;37m\]$\[\033[00m\] '

пользовательский фон терминала имеет цветовой номер #042433

ps aux | grep mick | cut -d ' ' -f 2-10 - выведет номера процессов, запущенных от имени пользователя mick

ps aux | firefox | cut -d ' ' -f 2-10 > pid_firefox; for i in $(cat  pid_firefox); do kill $i; done  - определяем  номера процессов, связанных с программой firefox, и убиваем их

docker images | awk '{ if($1=="<none>") print $3}' - команда выведет id всех "бесхозных" контейнеров (которые имеют имя <none>)

alias python='python3'
alias ipython='ipython3'
alias pip='pip3'

alias d='docker'
alias dcl='docker container list'
alias dcla='docker container list -a'
alias di='docker images'
alias dv='docker volume list'
alias drm='docker rm'
alias drmi='docker rmi'
alias drt='docker run -it --rm -p 8000:8000'
alias drd='docker run -d --name dc -p 8000:8000'
alias dbt='docker build -t'
alias dp='docker ps'
alias dc='docker-compose'
alias dci='docker-compose exec web pipenv install'
alias dcm='docker-compose exec web python manage.py'

alias gi='git init'
alias gs='git status'
alias gl='git log'
alias ga='git add .'
alias gc='git commit -m'
alias gp='git push'
alias gf='git fetch'
alias gu='git pull'

alias cv='if git remote -v 2> /dev/null | grep 63 > /dev/null; then cp /root/.ssh/config_karyshev63rus /root/.ssh/config && echo "KARYSHEV63RUS"; elif git remote -v 2> /dev/null | grep m > /dev/null; then cp /root/.ssh/config_karyshevm /root/.ssh/config && echo "KARYSHEVM"; else echo "NO YOUR REPO HERE"; fi'

alias t='tree -L 1'
alias tt='tree -L 2'
alias ttt='tree -L 3'
alias tttt='tree -L 4'
alias ttttt='tree -L 5'

PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u \[\[\033[01;34m\]\w\[\033[00m\]\[\033[1;36m\]$(gitPS1)\[\033[00m\]\[\033[1;37m\]$\[\033[00m\] '

adduser -m -s /bin/bash test - создать пользователя test с домашней директорией /home/test (ключ -m) и командной оболочкой (понятно какой, для чего ключ -s)
passwd test - задать пароль созданному пользователю
deluser - удалить созданного пользователя (его домашний каталог надо удалять отдельно)

apt-команды:
list - вывести список всех пакетов, доступных в системе (в т.ч. установленных)
install - устанавливает указанный пакет в систему
remove - удаляет указаный пакет из системы
purge - удаляет пакет и все файлы, связанные с пакетом (к примеру, конфиги и созданные в ходе работы файлы)
autoremove - удаляет пакеты, которые не используются в системе и не числятся зависимостями ни у одного пакета
update - обновляет список пакетов из репозиториев
upgrade - обновляет все пакеты, которые есть в системе (как правило, перед этой командой стоит обновлять и список пакетов)
search - позволяет найти пакет по имени
apt list --installed - выводит список установленных пакетов
apt -list --installed | grep lib | wc -l - выводит число установленных пакетов с названиями, вкючающими lib

tail -n 5
tail -f
python showtime.py >> logger.err & - дописывает в фоновом режиме
cp -R . ../skillbox2/
rm -r ../skillbox2
rm -r log*
mc
mcedit myfile
cat file1 file2 > total_file
df -h - занятое/свободное место на диске
du -h ./* - можно указать маски требуемых файлов
ls . > ls.log 2> ls-errors.log - одновременно пишем в два потока
ls . 1>> ls.log 2>> ls-errors.log - то же, но уже дописываем
wc myfile - выводит статистику (строки, слова, символы) по файлу
wc < myfile - или так
mysql dbname < file.sql - так заливаются файлы в БД типа mysql
ls -l | grep "\.log"
grep -R "date" ./ - выводит строки со словом date из файлов в текущем каталоге
grep -Rl "date" ./ - выведет имена таких файлов (поиск файлов по их содержимому)
addgroup mygroup - создаем группу
useradd mick -g mygroup - создаем пользователя и добавляем его в группу
chown mick:mygroup ./myfile - меняем владельца файла myfile с прежнего на пользователя mick из группы mygroup
chown mick:mygroup ./ - поменять владельца для всего текущего каталога


Подключение к серверу через:
----------------------------

1. логин и пароль
-----------------
1.1. ssh имя_пользователя@ip_адрес_хоста - жмем Enter
1.2. имя_пользователя@ip_адрес_хоста password: - вводим пароль

2. ssh-ключ
-----------
2.1. ssh-keygen -t rsa -b 4096 -C "email@example.com" - генерируем ssh-ключи

wget ftp://login:password@ftp.example.com/some_file.iso

wget -r -l 0 ftp://login:password@ftp.example.com/folder - скачивание каталога (-r - рекурсивно, -l 0 - с указанием уровня - он здесь равен нулю, т.е. скачиваем весь каталог)

скачивание по протоколу ssh
scp -r root@109.85.17.36:/home/ /home/mick/server-data/ - сначала указывается адрес сервера и скачиваемый каталог, а потом каталог на домашней машине куда планируется скачивание

python get_time.py >> time_store.log - работает в консоли
ping google.com >> google_ping_store.log
^z - останавливаем работу программы
bg - переводим в фоновый режим
python get_time.py >> time_store.log & - запуск изначально в фоновом режиме
ping google.com >> google_ping_store.log &

jobs -l - выводит список запущенных пользователем процессов в рамках текущей сессии (выводит три статуса программы: Running, Stoted, Done)

fg - возвращение программы на "передок", т.е. foreground


ps -A - выводит все процессы в системе
ps -a - процессы, связанные с текущим терминалом

crontab -l - просмотр расписания пользователя
crontab -e - переход к редактированию файла расписания пользователя
MAILTO='mike6376@mail.ru' - указываем в файле почту для связи
Параметры:
m h dom mon dow
где
m -  минута (0-59)
h - час (0-23)
dom - день месяца (1-31)
mon - месяц (1-12)
dow - день недели (0-7), воскресенье - 0 или 7
Каждый из параметров м.б. заменен *
* * * * * command
Возможные значения
35 - конкретное значение
0,20,40 - несколько значений
1-5 - диапазон значений
*/10 - кратность значений 
Например, каждый день в 5.35 утра запускаем скрипт из файла  script.py
m   h   dom   mon   dow   command
35  5    *     *     *    python script.py

export EDITOR=vim
echo $EDITOR - выведет на экран vim
export EDITOR='' - удаление значения переменной окружения (замена значения пустой строкой)

Ctrl + L - команда очистки экрана
Ctrl + D - команда завершения сессии
Ctrl + R - команда поиска по истории команд
Ctrl + J - команда прекращения поиска и перехода к работе с найденной командой

bash script.sh - можно запускать исполняемый файл и таким образом
#!/bin/bash или #!/usr/bin/env bash - разные варианты путей до интерпретатора

DATE=$(date); echo $DATE;

echo $0 - печатаем название скрипта, записанное в переменную $0

if [ "$1" != ""]
then
    echo "YES"
else
    echo "NO"
fi

Операторы "=" и "==" идентичны: [ "$a" = "$b" ] и [ "$a" == "$b" ]
[ "$a" -eq "$b" ] - равно
[ "$a" -ne "$b" ] - не равно

Файловые операторы
if [ -f filename ] - файл существует
if [ -d filename ] - директория существует
if [ -r filename ] - файл существует и readable
if [ -w filename ] - файл существует и writable
if [ file1 -nt file2 ] - "is newer than"
if [ file1 -ot file2 ] - "is older than"

----
DIRECTORIES='/test  /test2 /test3'
for DIRNAME in $DIRECTORIES
do
	echo "Directory: $DIRNAME"
done
----
for i in {1..10}
do
	echo $i
done
----
COUNTER=0
while [[ $COUNTER -lt 10 ]]
do
	echo "The counter is: $COUNTER"
	let COUNTER=COUNTER+1
done

COUNTER+=1 - такой вариант тоже работает
----
while [ "$1" != "" ]
do
	echo "Parameter equals $1"
	shift
done
----

$(date +%Y%m%d_%H%M%S) - способ форматирования даты

mysqldump --opt -u $DBUSER -p$DBPASS --events --all-databases >
$BACKUP_DIR/all.sql - использование программы dump

tar -cjf $BACKUP_DIR/all.sql.tbz -C $BACKUP_DIR/ all.sql - создание архивов при помощи команды tar

FILENAME=`echo $DIRNAME | sed 's/[\/]/\_/g' | sed 's/^\_|+\|\_\+$//g'` - способ очистить путь от слэшей и другого мусора

find ./* -type d -mtime +$DAYS_TO_STORE | xargs -r rm -R  - способ удаления старых папок (т.е. созданных более определенного числа дней назад)

ps auxww | grep 'celery worker' | awk '{print $2}' | xargs kill -9 - убиваем рабочий процесс celery


Утилита SCREEN
--------------
Основные команды (выполняются как комбинация префикса Ctrl+a (обозначу как ^) и что-то буквенно-цифровое ):
screen - запуск в терминале (выход - exit вплоть до сообщения 'screen is terminated')
^ и S - разделение экрана по горизонтали (области одна под другой)
^ и | - разделение экрана по вертикали (области одна рядом с другой)
^ и Tab - переход между созданными областями экрана (сессии)
^ и c - создание новых интерфейсов (иначе говоря, запуск терминалов, запуск новых сессий)
^ и 1...9  - переключение между экранами (может ли их быть 9 - не знаю, не проверял)
^ и n (p) - переключение на следующий (предыдущий) экран
^ и x - скрытие окна (как показала практика, команда схлопывает все окна экрана в одно окно) 
^ и - Q - команда скрывает все окна и оставляет только текущее (что-то подобное происходит после команды ^ и x)
^ и А - команда переименования окон (внизу появляется строка для введения нового названия)
^ и \ - скрытие всех окон сессии (следуем подтвердить решение нажатием клавиши y) 
^ и ? - список горячих клавиш
screen -S <sessionname> - при создании новой сессии можно задать ей имя
screen ls - команда просмотра списка запущенных сессий
screen -r <id или название сессии> - команда перехода к определенной сессии
Пример использования: 1)открываем два окна; 2) в первом открываем на редактирование файл <filename> и вносим в него изменений, а во втором - вводим команду tail -f <filename> и наблюдаем за появлением новых строк в stdout.
Таким образом, имея один терминал, можно создавать несколько окон для обработки параллельных процессов без конфликтов между ними.

sudo update-alternatives --config x-terminal-emulator - изменить терминал (на экран будет выведен список, где терминал по умолчанию будет помечен звездочкой; далее для смены терминала на  требуемый нужно будет ввести его номер)

ps --no-headers -o comm 1 - определение вида системы инициализации (init или systemd)
systemctl - инструмент управления службами в linux, утилита
systemctl list-unit-files - выведет все установленные файлы служб
systemctl list-unit-files --type service - только службы linux
systemctl list-unit-files service --state running - выведет только выполняющиеся службы
... --state failed - или те, которые завершились с ошибкой

... start <service_name> - запуск службы
... restart <service_name> - перезапуск службы 
... reload <service_name> - обновление конфигурации службы из файла юнита
... stop <service_name> - остановка
... status <service_name> - проверка статуса
... enable <service_name> - включение в список автоматически запускаемых при запуске системы
... disable <service_name> - исключение из вышеуказанного списка
... is-enabled <service_name> - проверка нахождения в вышеуказанном списк

python -c 'print("Hi there!")' - питон исполнит содержимое строки в баш

Команда, позволяющая генерировать пароль, которым можно потом заменить текущий хэш, что записан в /etc/shadow: openssl passwd -1 -salt xyz yourpass


Справочник Граннемана "Linux. Карманный справочник. Необходимый код и команды"
==============================================================================
ls -1 - вывод в один столбец
ls -t - вывод с сортировкой по дате и времени
ls -laS - вывод с сортировкой по размеру файлов
mkdir -v - вывод информации о действиях, выполняемых командой mkdir
cd -i - оповещение о копировании с запросом на выполнение копирования (важно, когда есть вероятность "затереть" важные файлы)
rm -i - то же, но в случае с удалением важных файлов
su -l <username >- переход под акк другого пользователя со всеми его правами и каталогами
whatis ls - выводит предназначение указанной команды
$() - использование выходных данных одной команды при вызове другой команды:
for item in $(ls); do echo $item; done
Передача содержимого из файлов в файл:
cat fileA fileB > fileC
Вывод содержимого файла с указанием строк::
cat (less) -N file
head -n file - выведет первые n строк файла
tail -f <filename or smth> - просмотр обновляемых строк в конце файла
chgrp - команда смены прав для группы пользователей
Установка и сброс suid: chmod u[+-]s 
Установка и сброс sgid: chmod g[+-]s
Установка и сброс признака "sticky bit": chmod [+-]t
Команда zip используется как для архивирования, так и сжатия файлов:
zip -1 moby.zip *txt - сжимаем с уровнем 1 файлы с расширением txt и создаем архив mobi
unzip <archivename>.zip - разархивирование zip-архива
unzip -l moby.zip - получение списка файлов из архива
unzip -t ... - то же, но проверка файлов (на предмет их поврежденности)
-P -e - флаги для установки паролей на zip-архивы:
zip -e -5 moby.zip *txt (далее будут запросы на 'Enter password:' и 'Verify password:')
gzip и bzip2 - в общем и целом, то же, что и zip
Команда tar только лишь создает архивы, но не сжимает исходные файлы (для этого вместе с ней используются команды gzip и bzip2)
tar -zcvf moby.tar.gz moby-dick/ - сжатие (gzip) и архивирование (tar) каталога mobi
tar -jcvf moby.tar.bz2 moby-dick/ - то же, но с архиватором bzip2
Проверка файлов, предназначенных для распаковки с разархивирования:
tar -zvtf moby.tar.gz (-t - от слова test)
tar -jvtf moby.tar.bz2
Распаковка и разархивирование файлов (если -c - это create, то -x - соответственно, extract):
tar -zxvf moby.tar.gz
tar -jxvf moby.tar.bz2

ПОИСК ДАННЫХ (LOCATE, GREP, FIND)
Поиск данных на основе созданной базы данных командой locate:
locate misterX или locate mick | wc -l
locate -i smth - поиск без учета регистра
updatedb - обновление базы данных
Поиск фрагментов текстового файла командой grep: 
grep pattern <filename>
grep pattern *
grep -R pattern * - рекурсивный поиск
grep -w smth * - поиск слов
ps -fu <username> - перечень процессов пользователя <username> (-u) с подробной информацией (-f) 
ps -fu mick | grep [f]irerox
Просмотр контекста для слов (-A -B -C)
ls | grep -A 3 log
grep -v - отображение строк, не содержащих искомых подстрок
grep -l <smth word> <smtn dir>/* - отображение списка файлов, содержащих указанную подстроку
Поиск файлов по имени и другим атрибутам командой find:
find . -name "*<filename>*" - поиск в текущем каталоге файла с именем <filename> (почему-то иногда это выражение приводит к рекурсивному поиску, что очень неудобно. Видимо, не совсем правильно его применяю)
grep . ! -user mick - поиск файлов, не принадлежащих пользователю mick
grep -group - поиск файлов по имени группы
grep - size - то же,  но по размеру, например: find . -size +10M (поиск файлов размеров более 10 Мб, если указать 10М, то будут искаться файлы размером точно 10Мб)
grep -type - то же, но по типу файлов
grep -a - отображение результатов при выполнении всех выражений, например:
find . -name 'Rolling_Stones*' -a -type f - найдутся файлы с соответствующими названиями
find -o - отображение результатов при выполнении любого из условий поиска
find . \( -name "*mp3*" -o -name "*.ogg*" -o -name "*.flac" \) -a -type f | wc -l
find -n - отображаются результаты, если выражение не выполняется (в примере почему-то используется знак !)
Использование команды exec в констексте результатов команды find:
find . -name " *MP3" -exec rename 's/MP3/mp3/g' {} \;
find . -name "* *m3u" -exec rename 's/\ /_/g' {} \;

Оболочка
--------
history - список команд из истории
!! - выполнение предыдущей команды
!<command number> - вызов команды с номером <comand number> из истории

Процессы
---------
ps axjf и ps axuf - просмотр дерева процессов
ps U <username> - просмотр процессов конкретного пользователя
lsof - список открытых файлов
lsof -u - список файлов, открытых конкретных пользователем
lsof <filename> - список пользователей данного файла
lsof -c <programname> - сведения о процессах, соответствующих конкретной программе
free - отображение инфы об оперативной памяти системы (флаги -b, -k, -m)
df -h - отображение инфы об использовании дискового пространства
du - определение размера области, занятой содержимым каталога
du -s - ограничение размера вышеуказанной области (т.е. без вывода инфы о подкаталогах):
cd sandbox; du -hs

Сети
----
ifconfig - interface configuration - определение состояния сетевых интерфейсов
ifconfig - получение инфы о состоянии интерфейса беспроводной связи
ping - (ping -c) способность компьютера принимать запросы, например: ping -c 3 www.docent63.ru
traceroute - контроль прохождения пакетов между двумя узлами (traceroute docent63.ru)
host - выполнение dns-преобразования
ifup - активизация сетевого соединения (ifup eth0)
ifdown - перевод сетевого интерфейса в неактивное состояние
route - отображение таблицы маршрутизации
ssh - организация защищенного соединения с удаленным компом: ssh username@servername
ssh-copy-id -i ~/.ssh/id_dsa.pub username@servername - копирование публичного ssh-ключа на удаленный компьютер
rsync -v - защищенная передача файлов и создание резервных копий
curl -o <smth https-address> - опция "о" указывает на то, что данные будут записаны в файл и что имя создаваемого файла на локальном компьютере должно совпадать с именем соответствующего файла на удаленной машине

REGEXP
------
Общая схема: grep параметры шаблон имена_файлов
grep -c - выводит кол-во строк, соответствующих шаблону
grep -f - читать шаблон поиска из файла
grep -n - вывести номер строки, в которой было найдено совпадение с шаблоном
grep -r (или -R) - рекурсивный поиск по подкаталогам
grep -E (или просто egrep) - включить расширенное регулярное выражение
используется с кавычками, например: egrep 't.?o' frost.txt
Метасимволы
-----------
. - соответствует любому символу, кроме символа новой строки
? - делает любой предшествующий ему символ необязательным; т.е. символ сопоставляется один раз, далее игнорируется (так, в вышеуказанном примеры могут быть найдены и to, и too, и two)
* - соответствует предыдущему символу неограниченное кол-во раз (от нуля и до бесконечности), например: grep 'T.*o' frost.txt - найдутся To, Too, Two и даже The Ro (из строки The Road)
+ - работает так же, как и *, но предыдущий ему элемент должен встретиться хотя бы однажды. Иначе говоря, он соответствует предыдущему элементы, который появляется один раз или более. Значит, egrep 'T.+o' frost.txt выведет такие фрагменты, как Two, а также To where it bent in the undergro и The Ro 
Разные скобки
-------------
Группирование 
less /etc/passwd | egrep 'm(ic|ac)k'
Классы и списки допустимых символов
... 'mi[abc]k' ... или 'mi[a-z]k'
Символы \s \d \w и тому подобные egrep не поддерживаются, их надо использовать так:
grep -P '\d' frost.txt
Символьные классы типа [:alnum:] используются с применение дополнительных скобок:
grep 'X[[:upper:][:digit:]]' idlist.txt - выведет строки, в которых после символа Х идет любая прописная буква или цифра (User: TXJonson или an XWing model 7 или an X7wing model) 
Обратные ссылки
---------------
Нижеприведенное выражение найдет все парные теги в файле, если они расположены в одной и той же строке
egrep '<([A-Za-z0-9]*)>.*</\1>' index.html
Здесь обратная ссылка \1 расположена в последней части регулярки и направляет к выражению в передней части, представляющей собой шаблон html-тега
Можно использовать несколько обратных ссылок в выражении и обращаться к каждой как \1 \2 \3 в зависимости от ее порядка в регулярке
Круглые скобки являются здесь метасимволами, поэтому для обозначения собственно круглых скобок, их надо экранировать, например: sin\([0-9.]*\)
Квартификаторы
--------------
Указывают, сколько раз элемент должен появиться в строке и определяются фигурными скобками {}. Например, шаблон T{5} означает, что буква Т должна последовательно появляться 5 раз, а T{3,6} - от 3 до 6 раз, а T{5,} - 5 раз и более
Якоря и границы слов
--------------------
Если нужно указать, что шаблон должен находиться в начале или в конце строки, используются якоря ^ и $, например: ^E или [1-5]$
Шаблон \b используется для определения границы слова, например, \b[1-5]\b будет соответствовать любой цифре от 1 до 5, где цифра представлена словом (возможно, имеется ввиду, что цифра является отдельно стоящей в строке, например, 1 2 5)
Поиск строки, начинающейся с цифры и заканчивающейся цифрой, при этом между цифрами м.б. все что угодно: egrep '^[0-9].*[0-9]$' или grep -P '^\d*.*\d$'
Используя обратную ссылку, написать регулярку, чтобы, числа, находящиеся по обе стороны от знака равенства, соответствовали друг другу. Например, "314 = 314" - это правильно, а "6 = 7" - нет:
echo "314 = 314" | if egrep '(314) = \1'; then echo True; else False; fi
cat /proc/cpuinfo - файл с данными о ТТХ процессора
Копируем найденные по find и grep файлы в текущий рабочий каталог:
find /home -type f -exec grep 'password' '{}' \; -exec cp '{}' . \;

